# Refactoring Issue #9: Deeply Nested Early Returns in `switch_character`

## The Problem

### Current Implementation

```rust
// src/characters/spawn.rs
pub fn switch_character(
    input: Res<ButtonInput<KeyCode>>,
    mut character_index: ResMut<CurrentCharacterIndex>,
    characters_lists: Res<Assets<CharactersList>>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut query: Query<(
        &mut CharacterEntry,
        &mut Sprite,
    ), With<Player>>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    asset_server: Res<AssetServer>,
) {
    // Map digit keys to indices
    const DIGIT_KEYS: [KeyCode; 9] = [
        KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
        KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
        KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
    ];
    
    // Find which digit key was pressed
    let new_index = DIGIT_KEYS.iter()
        .position(|&key| input.just_pressed(key));
    
    let Some(new_index) = new_index else { return; };           // Guard 1
    let Some(characters_list_res) = characters_list_res else { return; };  // Guard 2
    let Some(characters_list) = characters_lists.get(&characters_list_res.handle) else { return; };  // Guard 3
    if new_index >= characters_list.characters.len() { return; }  // Guard 4
    let Ok((mut current_entry, mut sprite)) = query.single_mut() else { return; };  // Guard 5
    
    // ... actual logic (only 15 lines)
    character_index.index = new_index;
    let character_entry = &characters_list.characters[new_index];
    *current_entry = character_entry.clone();
    // ... sprite update
}
```

### What's Wrong?

#### 1. **Cognitive Load - "What Are the Prerequisites?"**

A reader must mentally track 5 conditions to understand when this function actually does work:
1. A digit key must have been pressed
2. The characters list resource must exist
3. The asset must be loaded
4. The index must be valid
5. The player entity must exist

Each `return` looks the same but has different semantics (no input vs missing asset vs invalid index).

#### 2. **No Distinction Between "Skip" and "Error"**

All early returns are silent:
- No key pressed â†’ expected, skip silently âœ“
- Asset not loaded yet â†’ expected during loading, skip silently âœ“
- Invalid index (pressed 9 but only 6 characters) â†’ maybe log a warning? ðŸ¤”
- No player entity â†’ bug? should this panic? ðŸ¤”

#### 3. **Linear Code Structure Hides Logical Grouping**

The conditions belong to different categories:
- **Input validation**: Was a key pressed?
- **Asset availability**: Is the asset loaded?
- **Data validation**: Is the index valid?
- **Entity availability**: Does the player exist?

But they're presented as a flat sequence.

#### 4. **Difficult to Test**

To test the actual switching logic, you must set up:
- Input simulation
- Asset loading
- Character data
- Entity spawning

The business logic is buried under 5 layers of availability checks.

#### 5. **Repeated Pattern in Similar Functions**

Look at `initialize_player_character` - same pattern:

```rust
pub fn initialize_player_character(...) {
    let Some(characters_list_res) = characters_list_res else { return; };
    for entity in query.iter_mut() {
        let Some(characters_list) = characters_lists.get(&characters_list_res.handle) else { continue; };
        if character_index.index >= characters_list.characters.len() { continue; };
        // ... actual logic
    }
}
```

---

## Solution A: Context Struct Pattern

Extract all prerequisites into a struct returned by a validation function.

### Define the Context

```rust
// src/characters/spawn.rs

/// All the data needed to perform a character switch.
/// If this can be constructed, all prerequisites are met.
struct SwitchContext<'a> {
    new_index: usize,
    character_data: &'a CharacterEntry,
}

impl<'a> SwitchContext<'a> {
    /// Attempt to gather all prerequisites for a character switch.
    /// Returns None if any prerequisite is not met.
    fn try_gather(
        input: &ButtonInput<KeyCode>,
        characters_list_res: Option<&CharactersListResource>,
        characters_lists: &'a Assets<CharactersList>,
    ) -> Option<Self> {
        // 1. Check for digit key press
        const DIGIT_KEYS: [KeyCode; 9] = [
            KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
            KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
            KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
        ];
        
        let new_index = DIGIT_KEYS.iter()
            .position(|&key| input.just_pressed(key))?;
        
        // 2. Get character list resource
        let list_res = characters_list_res?;
        
        // 3. Get loaded asset
        let list = characters_lists.get(&list_res.handle)?;
        
        // 4. Validate index
        let character_data = list.characters.get(new_index)?;
        
        Some(SwitchContext {
            new_index,
            character_data,
        })
    }
}
```

### Simplified System Function

```rust
pub fn switch_character(
    input: Res<ButtonInput<KeyCode>>,
    mut character_index: ResMut<CurrentCharacterIndex>,
    characters_lists: Res<Assets<CharactersList>>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut query: Query<(&mut CharacterEntry, &mut Sprite), With<Player>>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    asset_server: Res<AssetServer>,
) {
    // One clear validation point
    let Some(ctx) = SwitchContext::try_gather(
        &input,
        characters_list_res.as_deref(),
        &characters_lists,
    ) else {
        return;
    };
    
    // Entity check - separate because it's a different kind of prerequisite
    let Ok((mut current_entry, mut sprite)) = query.single_mut() else {
        return;
    };
    
    // Clean business logic - all prerequisites guaranteed
    character_index.index = ctx.new_index;
    *current_entry = ctx.character_data.clone();
    
    let texture = asset_server.load(&ctx.character_data.texture_path);
    let layout = create_character_atlas_layout(&mut atlas_layouts, ctx.character_data);
    
    *sprite = Sprite::from_atlas_image(
        texture,
        TextureAtlas { layout, index: 0 },
    );
}
```

---

## Solution B: Run Condition + Simplified System

Use Bevy's `run_if` to handle some prerequisites at the scheduling level.

### Define Run Conditions

```rust
// src/characters/conditions.rs
use bevy::prelude::*;

/// Run condition: character assets are loaded and available.
pub fn characters_loaded(
    characters_list_res: Option<Res<CharactersListResource>>,
    characters_lists: Res<Assets<CharactersList>>,
) -> bool {
    characters_list_res
        .and_then(|res| characters_lists.get(&res.handle))
        .is_some()
}

/// Run condition: any digit key (1-9) was just pressed.
pub fn digit_key_pressed(input: Res<ButtonInput<KeyCode>>) -> bool {
    const DIGIT_KEYS: [KeyCode; 9] = [
        KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
        KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
        KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
    ];
    DIGIT_KEYS.iter().any(|&key| input.just_pressed(key))
}

/// Run condition: player entity exists.
pub fn player_exists(query: Query<(), With<Player>>) -> bool {
    query.single().is_ok()
}
```

### Register with Run Conditions

```rust
// In CharactersPlugin
app.add_systems(Update,
    switch_character.run_if(
        characters_loaded
            .and(digit_key_pressed)
            .and(player_exists)
    )
);
```

### Ultra-Simplified System

```rust
/// Switch character - only runs when all prerequisites are met.
pub fn switch_character(
    input: Res<ButtonInput<KeyCode>>,
    mut character_index: ResMut<CurrentCharacterIndex>,
    characters_lists: Res<Assets<CharactersList>>,
    characters_list_res: Res<CharactersListResource>,  // No Option - guaranteed by run_if
    mut query: Query<(&mut CharacterEntry, &mut Sprite), With<Player>>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    asset_server: Res<AssetServer>,
) {
    const DIGIT_KEYS: [KeyCode; 9] = [
        KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
        KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
        KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
    ];
    
    // These are now the only checks needed
    let new_index = DIGIT_KEYS.iter()
        .position(|&key| input.just_pressed(key))
        .unwrap();  // Safe: run_if guarantees this
    
    let characters_list = characters_lists.get(&characters_list_res.handle)
        .unwrap();  // Safe: run_if guarantees this
    
    // Only this check remains - could also be a run_if
    let Some(character_entry) = characters_list.characters.get(new_index) else {
        warn!("Pressed key {} but only {} characters available", new_index + 1, characters_list.characters.len());
        return;
    };
    
    let (mut current_entry, mut sprite) = query.single_mut();  // Safe: run_if guarantees
    
    // Pure business logic
    character_index.index = new_index;
    *current_entry = character_entry.clone();
    
    let texture = asset_server.load(&character_entry.texture_path);
    let layout = create_character_atlas_layout(&mut atlas_layouts, character_entry);
    *sprite = Sprite::from_atlas_image(texture, TextureAtlas { layout, index: 0 });
}
```

---

## Solution C: Event-Based Decoupling

Separate "intent detection" from "action execution".

### Define an Event

```rust
// src/characters/events.rs
use bevy::prelude::*;

/// Event fired when a character switch is requested.
#[derive(Event)]
pub struct SwitchCharacterRequest {
    pub target_index: usize,
}
```

### Input Detection System

```rust
/// Detects character switch input and fires events.
pub fn detect_character_switch_input(
    input: Res<ButtonInput<KeyCode>>,
    mut events: EventWriter<SwitchCharacterRequest>,
) {
    const DIGIT_KEYS: [KeyCode; 9] = [
        KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
        KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
        KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
    ];
    
    if let Some(index) = DIGIT_KEYS.iter().position(|&key| input.just_pressed(key)) {
        events.send(SwitchCharacterRequest { target_index: index });
    }
}
```

### Event Handler System

```rust
/// Handles character switch events.
/// Has clear prerequisites - only reads events when ready.
pub fn handle_character_switch(
    mut events: EventReader<SwitchCharacterRequest>,
    mut character_index: ResMut<CurrentCharacterIndex>,
    characters_lists: Res<Assets<CharactersList>>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut query: Query<(&mut CharacterEntry, &mut Sprite), With<Player>>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    asset_server: Res<AssetServer>,
) {
    // Early exit if not ready - events will be consumed but that's OK
    let Some(list_res) = characters_list_res else { return };
    let Some(list) = characters_lists.get(&list_res.handle) else { return };
    let Ok((mut entry, mut sprite)) = query.single_mut() else { return };
    
    // Process all pending switch requests
    for event in events.read() {
        let Some(character_data) = list.characters.get(event.target_index) else {
            warn!("Invalid character index: {}", event.target_index);
            continue;
        };
        
        character_index.index = event.target_index;
        *entry = character_data.clone();
        
        let texture = asset_server.load(&character_data.texture_path);
        let layout = create_character_atlas_layout(&mut atlas_layouts, character_data);
        *sprite = Sprite::from_atlas_image(texture, TextureAtlas { layout, index: 0 });
    }
}
```

### Plugin Registration

```rust
app.add_event::<SwitchCharacterRequest>()
   .add_systems(Update, (
       detect_character_switch_input,
       handle_character_switch,
   ).chain());
```

---

## Solution D: Result-Based Flow with Inner Function

Use Rust's `?` operator with a local helper returning `Option` or `Result`.

### Pattern: Inner Function

```rust
pub fn switch_character(
    input: Res<ButtonInput<KeyCode>>,
    mut character_index: ResMut<CurrentCharacterIndex>,
    characters_lists: Res<Assets<CharactersList>>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut query: Query<(&mut CharacterEntry, &mut Sprite), With<Player>>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    asset_server: Res<AssetServer>,
) {
    // Inner function allows ? operator
    fn try_switch(
        input: &ButtonInput<KeyCode>,
        character_index: &mut CurrentCharacterIndex,
        characters_lists: &Assets<CharactersList>,
        characters_list_res: Option<&CharactersListResource>,
        entry: &mut CharacterEntry,
        sprite: &mut Sprite,
        atlas_layouts: &mut Assets<TextureAtlasLayout>,
        asset_server: &AssetServer,
    ) -> Option<()> {
        const DIGIT_KEYS: [KeyCode; 9] = [
            KeyCode::Digit1, KeyCode::Digit2, KeyCode::Digit3,
            KeyCode::Digit4, KeyCode::Digit5, KeyCode::Digit6,
            KeyCode::Digit7, KeyCode::Digit8, KeyCode::Digit9,
        ];
        
        let new_index = DIGIT_KEYS.iter()
            .position(|&key| input.just_pressed(key))?;
        
        let list_res = characters_list_res?;
        let list = characters_lists.get(&list_res.handle)?;
        let character_data = list.characters.get(new_index)?;
        
        character_index.index = new_index;
        *entry = character_data.clone();
        
        let texture = asset_server.load(&character_data.texture_path);
        let layout = create_character_atlas_layout(atlas_layouts, character_data);
        *sprite = Sprite::from_atlas_image(texture, TextureAtlas { layout, index: 0 });
        
        Some(())
    }
    
    // Entity check separate (different error semantics)
    let Ok((mut entry, mut sprite)) = query.single_mut() else { return };
    
    // Call inner function - single return point
    let _ = try_switch(
        &input,
        &mut character_index,
        &characters_lists,
        characters_list_res.as_deref(),
        &mut entry,
        &mut sprite,
        &mut atlas_layouts,
        &asset_server,
    );
}
```

---

## Comparison of Solutions

| Aspect | Context Struct | Run Conditions | Event-Based | Inner Function |
|--------|---------------|----------------|-------------|----------------|
| **Complexity** | Medium | Low | Medium | Low |
| **Reusability** | High (context reusable) | High (conditions composable) | High (events decouple) | Low (local only) |
| **Testability** | High | Medium | High | Medium |
| **Bevy Idiomatic** | Medium | Very High | Very High | Medium |
| **Prerequisites Clear** | Yes (in struct) | Yes (in run_if) | Somewhat | Yes (in chain) |
| **Error Logging** | Easy to add | Harder | Easy | Easy |
| **Works with Multiple** | Need refactor | Easy | Natural | Need refactor |

**Recommendation:** 
- For simple cases: **Run Conditions** (Solution B)
- For complex validation: **Context Struct** (Solution A)
- For decoupled architecture: **Event-Based** (Solution C)

---

## Design Principles Applied

### 1. **Fail-Fast Principle**

> Fail immediately and visibly when something goes wrong.

The context struct makes prerequisites explicit:

```rust
// If SwitchContext::try_gather returns Some, ALL prerequisites are met
let Some(ctx) = SwitchContext::try_gather(...) else {
    return;  // One clear failure point
};
```

### 2. **Single Level of Abstraction Principle (SLAP)**

> Each function should operate at a single level of abstraction.

Before: Mixed abstraction levels
```rust
// Low-level: key detection
let new_index = DIGIT_KEYS.iter().position(...);
// Medium-level: asset access
let characters_list = characters_lists.get(...);
// High-level: business logic
*current_entry = character_entry.clone();
```

After: Separated by abstraction
```rust
// try_gather: handles all low/medium level setup
// system body: pure high-level business logic
```

### 3. **Guard Clause Pattern (Refined)**

Guard clauses are good, but they should be:
- **Grouped logically** (not just linearly listed)
- **Distinguishable** (skip vs error)
- **Documented** (why does this guard exist?)

```rust
// Good: Guards with meaning
let Some(ctx) = SwitchContext::try_gather(...) else {
    // Expected: no input or asset not ready
    return;
};

let Ok((mut entry, mut sprite)) = query.single_mut() else {
    // Bug: player should always exist at this point
    error!("switch_character called but no player entity exists!");
    return;
};
```

### 4. **Command-Query Separation (CQS)**

The context struct separates:
- **Query**: `try_gather` - reads data, returns context
- **Command**: system body - mutates state

### 5. **Dependency Injection via Context**

The context struct acts as a dependency container:

```rust
struct SwitchContext<'a> {
    new_index: usize,
    character_data: &'a CharacterEntry,
}
```

Business logic receives exactly what it needs, no more.

### 6. **Parse, Don't Validate**

A principle from typed functional programming:

> Instead of validating data and then using it (with the possibility of forgetting validation), parse data into a type that can only exist if valid.

```rust
// Validating: Check then use (can forget checks)
if new_index.is_some() && list_res.is_some() && ... {
    // Easy to forget a check
}

// Parsing: Create type that proves validity
let ctx = SwitchContext::try_gather(...)?;
// ctx existing proves all checks passed
```

### 7. **Information Hiding**

The context struct hides validation complexity:

```rust
// Consumer doesn't need to know about:
// - DIGIT_KEYS array
// - Asset handle lookup
// - Index bounds checking
// They just get a valid SwitchContext or None
```

### 8. **Cohesion**

Related checks are grouped together:

```rust
impl SwitchContext {
    fn try_gather(...) {
        // All input-related checks
        // All asset-related checks  
        // All validation checks
        // Return cohesive result
    }
}
```

---

## Bonus: Logging Strategy

Add structured logging to understand failures:

```rust
impl<'a> SwitchContext<'a> {
    fn try_gather(
        input: &ButtonInput<KeyCode>,
        characters_list_res: Option<&CharactersListResource>,
        characters_lists: &'a Assets<CharactersList>,
    ) -> Option<Self> {
        const DIGIT_KEYS: [KeyCode; 9] = [...];
        
        let new_index = DIGIT_KEYS.iter()
            .position(|&key| input.just_pressed(key))?;
        
        trace!("Character switch requested: index {}", new_index);
        
        let list_res = characters_list_res.or_else(|| {
            debug!("Character switch skipped: asset handle not available");
            None
        })?;
        
        let list = characters_lists.get(&list_res.handle).or_else(|| {
            debug!("Character switch skipped: asset not loaded yet");
            None
        })?;
        
        let character_data = list.characters.get(new_index).or_else(|| {
            warn!("Character switch failed: index {} out of bounds (max: {})", 
                  new_index, list.characters.len());
            None
        })?;
        
        info!("Switching to character: {}", character_data.name);
        
        Some(SwitchContext { new_index, character_data })
    }
}
```

---

## Testing Benefits

### Before: Hard to Test

```rust
#[test]
fn test_switch_character() {
    // Need to set up:
    // - App with keyboard input plugin
    // - Asset server with loaded assets
    // - Entity with Player component
    // - Character list resource
    // ðŸ˜° Complex test setup
}
```

### After: Easy to Test Core Logic

```rust
#[test]
fn test_switch_context_valid_index() {
    // Create minimal mock data
    let characters = vec![
        CharacterEntry { name: "Test".into(), ... },
    ];
    let list = CharactersList { characters };
    
    // Test the context creation directly
    // No need for full Bevy app!
}

#[test]
fn test_switch_context_invalid_index() {
    // Test boundary conditions easily
}

#[test]  
fn test_character_switch_application() {
    // Test business logic with pre-validated context
    let ctx = SwitchContext { new_index: 0, character_data: &mock_data };
    // Apply and verify - no input/asset mocking needed
}
```

---

## Migration Checklist

- [ ] Create `SwitchContext` struct with lifetime parameter
- [ ] Implement `try_gather` method with clear validation chain
- [ ] Refactor `switch_character` to use context pattern
- [ ] Add appropriate log levels (trace/debug/warn/error)
- [ ] Consider adding run conditions for common prerequisites
- [ ] Apply same pattern to `initialize_player_character`
- [ ] (Optional) Extract digit key detection to shared utility
- [ ] Write unit tests for `try_gather` validation logic

---

## File Structure After Refactoring

```
src/characters/
â”œâ”€â”€ mod.rs
â”œâ”€â”€ spawn.rs           â†’ Uses SwitchContext
â”œâ”€â”€ context.rs         â†’ NEW: SwitchContext, InitContext (if needed)
â”œâ”€â”€ conditions.rs      â†’ NEW: Run conditions (characters_loaded, etc.)
â””â”€â”€ ...
```

Or inline the context struct if it's only used in one place - the pattern is what matters, not necessarily a new file.

