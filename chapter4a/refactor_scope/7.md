# Refactoring Issue #7: Movement System Tightly Coupled to Animation

## The Problem

### Current Implementation

```rust
// src/characters/movement.rs
pub fn move_player(
    input: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(
        &mut Transform, 
        &mut AnimationController,
        &mut AnimationState,
        &CharacterEntry,
    ), With<Player>>,
) {
    let Ok((mut transform, mut animated, mut state, character)) = query.single_mut() else {
        return;
    };
    
    let direction = read_movement_input(&input);
    
    // Check for jump input (space key)
    if input.just_pressed(KeyCode::Space) {
        state.is_jumping = true;
        animated.current_animation = AnimationType::Jump;  // ❌ Animation logic here!
    }
    
    let is_running = input.pressed(KeyCode::ShiftLeft) || input.pressed(KeyCode::ShiftRight);
    
    if direction != Vec2::ZERO {
        // ... movement code ...
        
        animated.facing = Facing::from_direction(direction);
        
        if !state.is_jumping {
            state.is_moving = true;
            animated.current_animation = if is_running {  // ❌ Animation logic here!
                AnimationType::Run
            } else {
                AnimationType::Walk
            };
        }
    } else if !state.is_jumping {
        state.is_moving = false;
        animated.current_animation = AnimationType::Walk;  // ❌ Animation logic here!
    }
}
```

### What's Wrong?

#### 1. **Violation of Single Responsibility Principle**

The `move_player` function has multiple responsibilities:
- Reading input
- Calculating velocity/direction
- Updating position
- Managing jump state
- **Selecting which animation to play** ← Doesn't belong here!

#### 2. **Tight Coupling Creates Modification Cascades**

Want to add knockback from an enemy hit? You need to:
1. Create the knockback system
2. Also update animations in that system
3. Handle conflicts with `move_player`'s animation choices
4. Worry about which system runs first

```rust
// New knockback system - must also handle animations!
pub fn apply_knockback(
    mut query: Query<(&mut Transform, &mut Velocity, &mut AnimationController, &Knockback)>,
) {
    for (mut transform, mut velocity, mut animation, knockback) in query.iter_mut() {
        velocity.0 = knockback.direction * knockback.force;
        animation.current_animation = AnimationType::Hurt;  // ❌ Duplicated animation logic
    }
}
```

#### 3. **Hidden Dependencies**

The movement system queries `AnimationController` but that's not obvious from its name. A developer looking at system dependencies wouldn't expect movement to touch animations.

#### 4. **Testing Difficulty**

To test movement physics, you must:
- Set up animation components
- Mock animation assets
- Deal with animation state

Movement logic should be testable in isolation.

#### 5. **Composability Problems**

Consider these future features:

| Feature | Problem with Current Design |
|---------|----------------------------|
| AI-controlled characters | AI movement also needs to set animations |
| Cutscene movement | Scripted paths must also handle animations |
| Network sync | Received positions must trigger correct animations |
| Replay system | Replayed inputs must reproduce animations |

Each would need to duplicate the animation selection logic.

---

## The Solution: Event-Driven Decoupling

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                        INPUT LAYER                                   │
│  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐   │
│  │  Player Input   │   │   AI Decision   │   │ Network Events  │   │
│  └────────┬────────┘   └────────┬────────┘   └────────┬────────┘   │
└───────────┼─────────────────────┼─────────────────────┼─────────────┘
            │                     │                     │
            ▼                     ▼                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     MOVEMENT STATE LAYER                             │
│                                                                      │
│                    ┌──────────────────────┐                         │
│                    │   CharacterState     │                         │
│                    │   + Velocity         │                         │
│                    │   + Facing           │                         │
│                    └──────────────────────┘                         │
│                              │                                       │
└──────────────────────────────┼───────────────────────────────────────┘
                               │
              Changed<CharacterState> / Changed<Velocity>
                               │
            ┌──────────────────┴──────────────────┐
            ▼                                      ▼
┌───────────────────────────┐        ┌───────────────────────────┐
│    PHYSICS LAYER          │        │    ANIMATION LAYER        │
│                           │        │                           │
│  apply_velocity system    │        │  update_animation system  │
│  (Transform changes)      │        │  (AnimationController)    │
└───────────────────────────┘        └───────────────────────────┘
```

---

## New Component Design

### 1. Velocity Component

Represents desired movement, separate from position.

```rust
// src/characters/physics.rs
use bevy::prelude::*;

/// Linear velocity in world units per second.
/// Systems that want to move an entity modify this.
/// A physics system reads this to update Transform.
#[derive(Component, Debug, Clone, Copy, Default, Deref, DerefMut)]
pub struct Velocity(pub Vec2);

impl Velocity {
    pub const ZERO: Self = Self(Vec2::ZERO);
    
    pub fn new(x: f32, y: f32) -> Self {
        Self(Vec2::new(x, y))
    }
    
    pub fn is_moving(&self) -> bool {
        self.0 != Vec2::ZERO
    }
    
    pub fn speed(&self) -> f32 {
        self.0.length()
    }
    
    pub fn direction(&self) -> Option<Vec2> {
        if self.is_moving() {
            Some(self.0.normalize())
        } else {
            None
        }
    }
}
```

### 2. CharacterState Enum (from Issue #6)

```rust
// src/characters/state.rs
use bevy::prelude::*;

#[derive(Component, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum CharacterState {
    #[default]
    Idle,
    Walking,
    Running,
    Jumping,
}
```

### 3. Facing Component (Decoupled from AnimationController)

```rust
// src/characters/facing.rs
use bevy::prelude::*;

/// The direction a character is facing.
/// Separate from movement - character can face one way while moving another.
#[derive(Component, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Facing {
    Up,
    Left,
    #[default]
    Down,
    Right,
}

impl Facing {
    pub fn from_velocity(velocity: Vec2) -> Self {
        if velocity.x.abs() > velocity.y.abs() {
            if velocity.x > 0.0 { Facing::Right } else { Facing::Left }
        } else {
            if velocity.y > 0.0 { Facing::Up } else { Facing::Down }
        }
    }
}
```

---

## Refactored Systems

### 1. Input System (Pure Input → State)

```rust
// src/characters/input.rs
use bevy::prelude::*;
use super::{CharacterState, Velocity, Facing, CharacterStats};

/// Reads player input and updates movement-related components.
/// Does NOT touch animations directly.
pub fn handle_player_input(
    input: Res<ButtonInput<KeyCode>>,
    mut query: Query<(
        &mut CharacterState,
        &mut Velocity,
        &mut Facing,
        &CharacterStats,
    ), With<Player>>,
) {
    let Ok((mut state, mut velocity, mut facing, stats)) = query.single_mut() else {
        return;
    };
    
    // Read directional input
    let direction = read_movement_input(&input);
    let is_running = input.pressed(KeyCode::ShiftLeft) || input.pressed(KeyCode::ShiftRight);
    let wants_jump = input.just_pressed(KeyCode::Space);
    
    // Update facing based on input direction (if moving)
    if direction != Vec2::ZERO {
        *facing = Facing::from_velocity(direction);
    }
    
    // State machine transitions
    *state = determine_new_state(*state, direction, is_running, wants_jump);
    
    // Calculate velocity based on state
    *velocity = calculate_velocity(*state, direction, stats, is_running);
}

fn determine_new_state(
    current: CharacterState,
    direction: Vec2,
    is_running: bool,
    wants_jump: bool,
) -> CharacterState {
    match current {
        // Can't transition out of jumping until it completes
        CharacterState::Jumping => CharacterState::Jumping,
        
        // Jump takes priority
        _ if wants_jump => CharacterState::Jumping,
        
        // Movement states
        _ if direction != Vec2::ZERO => {
            if is_running { CharacterState::Running } else { CharacterState::Walking }
        }
        
        // Default to idle
        _ => CharacterState::Idle,
    }
}

fn calculate_velocity(
    state: CharacterState,
    direction: Vec2,
    stats: &CharacterStats,
    is_running: bool,
) -> Velocity {
    match state {
        CharacterState::Idle => Velocity::ZERO,
        CharacterState::Jumping => Velocity::ZERO,  // Or maintain previous velocity
        CharacterState::Walking => {
            Velocity(direction.normalize_or_zero() * stats.base_move_speed)
        }
        CharacterState::Running => {
            Velocity(direction.normalize_or_zero() * stats.base_move_speed * stats.run_speed_multiplier)
        }
    }
}

fn read_movement_input(input: &ButtonInput<KeyCode>) -> Vec2 {
    const MOVEMENT_KEYS: [(KeyCode, Vec2); 4] = [
        (KeyCode::ArrowLeft, Vec2::NEG_X),
        (KeyCode::ArrowRight, Vec2::X),
        (KeyCode::ArrowUp, Vec2::Y),
        (KeyCode::ArrowDown, Vec2::NEG_Y),
    ];
    
    MOVEMENT_KEYS.iter()
        .filter(|(key, _)| input.pressed(*key))
        .map(|(_, dir)| *dir)
        .sum()
}
```

### 2. Physics System (Velocity → Transform)

```rust
// src/characters/physics.rs

/// Applies velocity to transform. Pure physics, no game logic.
pub fn apply_velocity(
    time: Res<Time>,
    mut query: Query<(&Velocity, &mut Transform)>,
) {
    for (velocity, mut transform) in query.iter_mut() {
        if velocity.is_moving() {
            transform.translation += velocity.0.extend(0.0) * time.delta_secs();
        }
    }
}
```

### 3. Animation Sync System (State → Animation)

```rust
// src/characters/animation_sync.rs
use bevy::prelude::*;
use super::{CharacterState, Facing, AnimationController, AnimationType};

/// Reacts to state/facing changes and updates animation accordingly.
/// Completely decoupled from movement input.
pub fn sync_animation_to_state(
    mut query: Query<
        (&CharacterState, &Facing, &mut AnimationController),
        Or<(Changed<CharacterState>, Changed<Facing>)>
    >,
) {
    for (state, facing, mut controller) in query.iter_mut() {
        // Update facing in animation controller
        controller.facing = match facing {
            Facing::Up => super::animation::Facing::Up,
            Facing::Down => super::animation::Facing::Down,
            Facing::Left => super::animation::Facing::Left,
            Facing::Right => super::animation::Facing::Right,
        };
        
        // Select animation based on state
        controller.current_animation = match state {
            CharacterState::Idle => AnimationType::Walk,  // Frame 0 = idle pose
            CharacterState::Walking => AnimationType::Walk,
            CharacterState::Running => AnimationType::Run,
            CharacterState::Jumping => AnimationType::Jump,
        };
    }
}
```

---

## Adding New Movement Sources

### Example: Knockback System

With decoupled design, knockback is trivial:

```rust
// src/characters/knockback.rs
use bevy::prelude::*;
use super::{Velocity, CharacterState};

#[derive(Component)]
pub struct Knockback {
    pub direction: Vec2,
    pub force: f32,
    pub duration: Timer,
}

/// Applies knockback force, overriding normal velocity.
pub fn apply_knockback(
    time: Res<Time>,
    mut commands: Commands,
    mut query: Query<(Entity, &mut Velocity, &mut CharacterState, &mut Knockback)>,
) {
    for (entity, mut velocity, mut state, mut knockback) in query.iter_mut() {
        // Override velocity with knockback
        *velocity = Velocity(knockback.direction * knockback.force);
        
        // Could add a Stunned state
        // *state = CharacterState::Stunned;
        
        knockback.duration.tick(time.delta());
        
        if knockback.duration.finished() {
            commands.entity(entity).remove::<Knockback>();
        }
    }
}
```

The animation system automatically reacts - no modification needed!

### Example: AI Movement

```rust
// src/ai/movement.rs
use bevy::prelude::*;
use crate::characters::{CharacterState, Velocity, Facing, CharacterStats};

#[derive(Component)]
pub struct AIController {
    pub target: Option<Vec3>,
}

/// AI determines movement, sets same components as player input.
pub fn ai_movement(
    mut query: Query<(
        &AIController,
        &Transform,
        &mut CharacterState,
        &mut Velocity,
        &mut Facing,
        &CharacterStats,
    ), Without<Player>>,
) {
    for (ai, transform, mut state, mut velocity, mut facing, stats) in query.iter_mut() {
        let Some(target) = ai.target else {
            *state = CharacterState::Idle;
            *velocity = Velocity::ZERO;
            continue;
        };
        
        let to_target = (target - transform.translation).truncate();
        let distance = to_target.length();
        
        if distance < 5.0 {
            *state = CharacterState::Idle;
            *velocity = Velocity::ZERO;
        } else {
            let direction = to_target.normalize();
            *facing = Facing::from_velocity(direction);
            *state = CharacterState::Walking;
            *velocity = Velocity(direction * stats.base_move_speed);
        }
    }
}
```

Animation just works - same `sync_animation_to_state` handles AI and player!

### Example: Network Sync

```rust
// src/network/sync.rs

/// Receives network state updates, applies to local components.
pub fn apply_network_state(
    mut network_events: EventReader<NetworkCharacterUpdate>,
    mut query: Query<(&NetworkId, &mut CharacterState, &mut Velocity, &mut Facing, &mut Transform)>,
) {
    for event in network_events.read() {
        for (net_id, mut state, mut velocity, mut facing, mut transform) in query.iter_mut() {
            if net_id.0 == event.entity_id {
                *state = event.state;
                *velocity = event.velocity;
                *facing = event.facing;
                transform.translation = event.position;
                // Animation syncs automatically!
            }
        }
    }
}
```

---

## System Ordering

With decoupled systems, ordering becomes explicit and meaningful:

```rust
impl Plugin for CharactersPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, (
            // 1. Input/AI determines intent → State + Velocity
            handle_player_input,
            ai_movement,
            apply_knockback,
            
            // 2. State changes trigger animation updates
            sync_animation_to_state,
            
            // 3. Physics applies velocity to transform
            apply_velocity,
            
            // 4. Animation ticks frames
            tick_animations,
        ).chain());  // Explicit ordering
    }
}
```

Or use system sets for clarity:

```rust
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum CharacterSystems {
    Input,
    StateSync,
    Physics,
    Animation,
}

app.configure_sets(Update, (
    CharacterSystems::Input,
    CharacterSystems::StateSync,
    CharacterSystems::Physics,
    CharacterSystems::Animation,
).chain());

app.add_systems(Update, handle_player_input.in_set(CharacterSystems::Input));
app.add_systems(Update, sync_animation_to_state.in_set(CharacterSystems::StateSync));
app.add_systems(Update, apply_velocity.in_set(CharacterSystems::Physics));
app.add_systems(Update, tick_animations.in_set(CharacterSystems::Animation));
```

---

## Design Principles Applied

### 1. **Single Responsibility Principle (SRP)**

Each system now has one job:

| System | Single Responsibility |
|--------|----------------------|
| `handle_player_input` | Convert input → movement intent |
| `ai_movement` | Convert AI decision → movement intent |
| `apply_knockback` | Apply external forces |
| `sync_animation_to_state` | Sync animation to character state |
| `apply_velocity` | Apply velocity to position |
| `tick_animations` | Advance animation frames |

### 2. **Open/Closed Principle (OCP)**

> Software entities should be open for extension but closed for modification.

Adding knockback, AI, or network sync doesn't require modifying any existing system. We extend by adding new systems that write to the same components.

### 3. **Dependency Inversion Principle (DIP)**

> High-level modules should not depend on low-level modules. Both should depend on abstractions.

The abstraction is the component data (`CharacterState`, `Velocity`, `Facing`).

- Input systems depend on components (not animations)
- Animation systems depend on components (not input)
- Neither depends on the other

### 4. **Interface Segregation Principle (ISP)**

Systems query only what they need:

```rust
// Input system doesn't need animation components
Query<(&mut CharacterState, &mut Velocity, &CharacterStats), With<Player>>

// Animation sync doesn't need physics components
Query<(&CharacterState, &Facing, &mut AnimationController), Changed<CharacterState>>

// Physics doesn't need state or animation
Query<(&Velocity, &mut Transform)>
```

### 5. **Mediator Pattern (GoF)**

The component data (`CharacterState`, `Velocity`) acts as a mediator between systems. Systems don't communicate directly - they communicate through shared state.

```
Input System ──writes──▶ [CharacterState] ◀──reads── Animation System
                              │
                              │ No direct coupling!
```

### 6. **Observer Pattern (via Bevy's Changed<T>)**

Animation sync observes state changes reactively:

```rust
Query<..., Changed<CharacterState>>
```

This is the Observer pattern implemented at the ECS level - animation "subscribes" to state changes.

### 7. **Command-Query Responsibility Segregation (CQRS)**

Input/AI systems are **commands** (change state). Animation sync is a **query** (read state to determine animation). Physics is also a **command** (change position based on velocity).

### 8. **Composition Over Inheritance**

Instead of inheriting behavior, entities compose behavior through components:

```rust
// Player: has input-driven movement
commands.spawn((Player, CharacterState::default(), Velocity::default(), ...));

// AI: has AI-driven movement  
commands.spawn((AIController::default(), CharacterState::default(), Velocity::default(), ...));

// Both share: physics, animation sync (via same components)
```

### 9. **Data-Oriented Design**

Bevy ECS thrives on data-oriented design:
- Small, focused components
- Systems operate on component data
- Cache-friendly iteration
- Easy parallelization (systems with non-overlapping queries run in parallel)

---

## Comparison Summary

| Aspect | Before (Coupled) | After (Decoupled) |
|--------|------------------|-------------------|
| **Adding knockback** | Modify movement system, add animation handling | Add new system writing to Velocity |
| **Adding AI** | Duplicate animation logic | Add new system writing to CharacterState |
| **Testing movement** | Need animation mocks | Test Velocity/State in isolation |
| **System dependencies** | Hidden, implicit | Explicit through components |
| **Parallelization** | Limited (systems share mutable refs) | Better (systems have smaller queries) |
| **Code location** | Animation logic in movement file | Animation logic in animation file |

---

## Migration Checklist

- [ ] Create `Velocity` component in `physics.rs`
- [ ] Move `Facing` to its own component (out of `AnimationController`)
- [ ] Rename `move_player` to `handle_player_input`
- [ ] Remove `AnimationController` and `AnimationState` from input system query
- [ ] Create `sync_animation_to_state` system with `Changed<CharacterState>` query
- [ ] Create `apply_velocity` system for physics
- [ ] Update plugin system registration with proper ordering
- [ ] Add `Velocity` and `Facing` components to player spawn
- [ ] Test that animations still work correctly
- [ ] (Optional) Create SystemSets for explicit ordering

---

## File Structure After Refactoring

```
src/characters/
├── mod.rs
├── input.rs           → NEW: handle_player_input
├── physics.rs         → NEW: Velocity, apply_velocity  
├── state.rs           → CharacterState enum
├── facing.rs          → NEW: Facing enum (extracted from animation)
├── animation.rs       → AnimationController, tick_animations
├── animation_sync.rs  → NEW: sync_animation_to_state
├── stats.rs           → CharacterStats (from issue #5)
├── spawn.rs
└── config.rs
```

