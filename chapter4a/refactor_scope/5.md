# Refactoring Issue #5: Mixed Asset/Component Pattern

## The Problem

### Current Implementation

```rust
// src/characters/config.rs
#[derive(Component, Asset, TypePath, Debug, Clone, Serialize, Deserialize)]
pub struct CharacterEntry {
    pub name: String,
    pub max_health: f32,
    pub base_move_speed: f32,
    pub run_speed_multiplier: f32,
    pub texture_path: String,
    pub tile_size: u32,
    pub atlas_columns: usize,
    pub animations: HashMap<AnimationType, AnimationDefinition>,
}
```

### What's Wrong?

`CharacterEntry` is simultaneously:
1. **An Asset** - Loaded from a RON file (`characters.ron`) via Bevy's asset system
2. **A Component** - Attached directly to the player entity at runtime

This creates several problems:

1. **The entity carries data it doesn't need** - Fields like `texture_path`, `tile_size`, and `atlas_columns` are only used during sprite setup, not during gameplay. Yet they remain attached to the entity for its entire lifetime.

2. **Clone overhead** - When switching characters, the entire struct is cloned:
   ```rust
   // spawn.rs line 98
   commands.entity(entity).insert(character_entry.clone());
   
   // spawn.rs line 154
   *current_entry = character_entry.clone();
   ```

3. **Unnecessary memory per entity** - If you spawn multiple entities from the same character template, each carries a full copy of all configuration data including the `HashMap<AnimationType, AnimationDefinition>`.

4. **Violates Single Responsibility Principle** - The struct has two jobs: being serializable configuration AND being runtime game state.

5. **Makes future changes brittle** - Want to add a `description: String` for UI tooltips? It gets cloned into every entity. Want to add `unlocked: bool` for progression? Same problem.

---

## The Solution

### Split into Two Distinct Types

#### 1. `CharacterData` (Asset Only)

This is the **data definition** loaded from files. It describes what a character template looks like.

```rust
// src/characters/data.rs (new file)
use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Character template data loaded from RON files.
/// This is the "blueprint" for creating character entities.
#[derive(Asset, TypePath, Debug, Clone, Serialize, Deserialize)]
pub struct CharacterData {
    pub name: String,
    pub max_health: f32,
    pub base_move_speed: f32,
    pub run_speed_multiplier: f32,
    pub texture_path: String,
    pub tile_size: u32,
    pub atlas_columns: usize,
    pub animations: HashMap<AnimationType, AnimationDefinition>,
}

/// Container for the list of all character templates.
#[derive(Asset, TypePath, Debug, Clone, Serialize, Deserialize)]
pub struct CharacterDataList {
    pub characters: Vec<CharacterData>,
}
```

#### 2. `CharacterStats` (Component Only)

This is the **runtime state** attached to entities. It contains only what's needed during gameplay.

```rust
// src/characters/stats.rs (new file)
use bevy::prelude::*;

/// Runtime character stats attached to entities.
/// Contains only the data needed for gameplay systems.
#[derive(Component, Debug, Clone)]
pub struct CharacterStats {
    pub max_health: f32,
    pub current_health: f32,  // Runtime state!
    pub base_move_speed: f32,
    pub run_speed_multiplier: f32,
}

impl CharacterStats {
    /// Create runtime stats from character data template
    pub fn from_data(data: &CharacterData) -> Self {
        Self {
            max_health: data.max_health,
            current_health: data.max_health,  // Start at full health
            base_move_speed: data.base_move_speed,
            run_speed_multiplier: data.run_speed_multiplier,
        }
    }
}
```

#### 3. `CharacterVisuals` (Component for Animation)

Separate component for animation-related runtime data.

```rust
// src/characters/visuals.rs (new file)
use bevy::prelude::*;

/// Index into the CharacterDataList for looking up animation definitions.
/// Much cheaper than cloning the entire animation HashMap.
#[derive(Component, Debug, Clone, Copy)]
pub struct CharacterTemplate {
    pub index: usize,
}

impl CharacterTemplate {
    pub fn new(index: usize) -> Self {
        Self { index }
    }
}
```

---

## Updated Usage

### Before (Current Code)

```rust
// spawn.rs - attaching full CharacterEntry as component
commands.entity(entity).insert((
    AnimationController::default(),
    AnimationState::default(),
    AnimationTimer(Timer::from_seconds(DEFAULT_ANIMATION_FRAME_TIME, TimerMode::Repeating)),
    character_entry.clone(),  // Entire asset cloned as component!
    sprite,
));
```

### After (Refactored)

```rust
// spawn.rs - attach only what's needed
commands.entity(entity).insert((
    AnimationController::default(),
    AnimationState::default(),
    AnimationTimer(Timer::from_seconds(DEFAULT_ANIMATION_FRAME_TIME, TimerMode::Repeating)),
    CharacterStats::from_data(character_data),   // Only runtime stats
    CharacterTemplate::new(character_index),      // Just an index!
    sprite,
));
```

### Animation System Access

When the animation system needs animation definitions, it looks them up via the index:

```rust
pub fn animate_characters(
    time: Res<Time>,
    character_list_res: Res<CharacterDataListResource>,
    character_lists: Res<Assets<CharacterDataList>>,
    mut query: Query<(
        &AnimationController,
        &AnimationState,
        &CharacterTemplate,  // Just the index
        &mut AnimationTimer,
        &mut Sprite,
    )>,
) {
    let Some(list) = character_lists.get(&character_list_res.handle) else { return };
    
    for (controller, state, template, mut timer, mut sprite) in query.iter_mut() {
        // Look up animation data when needed
        let character_data = &list.characters[template.index];
        let Some(clip) = controller.get_clip(character_data) else { continue };
        
        // ... rest of animation logic
    }
}
```

---

## Design Principles Applied

### 1. **Single Responsibility Principle (SRP)**

> A module/struct should have one, and only one, reason to change.

| Before | After |
|--------|-------|
| `CharacterEntry` changes if serialization format changes OR if runtime behavior changes | `CharacterData` changes only for serialization; `CharacterStats` changes only for runtime behavior |

### 2. **Separation of Concerns**

The data layer (what gets loaded from files) is now cleanly separated from the runtime layer (what exists during gameplay).

```
┌─────────────────────────────────────────────────────────────┐
│                     DATA LAYER                               │
│  ┌─────────────────┐    ┌─────────────────────────────────┐ │
│  │ characters.ron  │───▶│ CharacterData (Asset)           │ │
│  └─────────────────┘    │ - name, texture_path, tile_size │ │
│                         │ - animations HashMap            │ │
│                         └─────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ from_data()
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    RUNTIME LAYER                             │
│  ┌─────────────────────┐  ┌─────────────────────────────┐   │
│  │ CharacterStats      │  │ CharacterTemplate           │   │
│  │ - max_health        │  │ - index: usize              │   │
│  │ - current_health    │  └─────────────────────────────┘   │
│  │ - base_move_speed   │                                    │
│  └─────────────────────┘                                    │
└─────────────────────────────────────────────────────────────┘
```

### 3. **Flyweight Pattern (GoF)**

> Use sharing to support large numbers of fine-grained objects efficiently.

The `CharacterTemplate { index: usize }` is a flyweight reference. Instead of each entity carrying a full copy of animation data, they all share the same loaded `CharacterDataList` asset and just store an index into it.

**Memory comparison:**
- Before: Each entity stores ~200+ bytes (String, HashMap, etc.)
- After: Each entity stores 8 bytes (usize index)

### 4. **Data-Oriented Design**

Bevy is built on ECS principles which favor data-oriented design. By keeping components small and focused:

- **Better cache utilization** - `CharacterStats` is small and fits in cache lines
- **Easier to query** - Systems can query only what they need
- **Parallelization** - Smaller components = less contention

### 5. **Open/Closed Principle**

> Software entities should be open for extension but closed for modification.

With the split design:
- Adding UI-only data (description, icon) goes in `CharacterData` only
- Adding runtime state (buffs, debuffs) goes in new components
- Neither change requires modifying the other

### 6. **Rust's Ownership Model - Borrowing Over Cloning**

The refactored design leverages Rust's borrowing:

```rust
// Before: Clone entire struct
character_entry.clone()

// After: Borrow from shared asset
let character_data = &list.characters[template.index];
```

This is more idiomatic Rust - prefer borrowing when you don't need ownership.

### 7. **Interface Segregation Principle (ISP)**

> Clients should not be forced to depend on interfaces they do not use.

The movement system only needs speed values:
```rust
// Only query CharacterStats, not animation data
Query<(&mut Transform, &CharacterStats), With<Player>>
```

The animation system only needs animation definitions:
```rust
// Look up CharacterData only when needed for animations
Query<(&AnimationController, &CharacterTemplate, &mut Sprite)>
```

---

## Additional Benefits

### 1. **Runtime State vs Initial State**

With the split, you can now have runtime state that differs from initial configuration:

```rust
#[derive(Component)]
pub struct CharacterStats {
    pub max_health: f32,
    pub current_health: f32,     // Can be damaged!
    pub base_move_speed: f32,
    pub current_speed_modifier: f32,  // Buffs/debuffs!
}
```

### 2. **Easy Character Reset**

Reset to original stats without reloading:

```rust
pub fn reset_character_stats(
    characters: Res<Assets<CharacterDataList>>,
    list_res: Res<CharacterDataListResource>,
    mut query: Query<(&CharacterTemplate, &mut CharacterStats)>,
) {
    let list = characters.get(&list_res.handle).unwrap();
    for (template, mut stats) in query.iter_mut() {
        let data = &list.characters[template.index];
        *stats = CharacterStats::from_data(data);
    }
}
```

### 3. **Multiple Entities, Same Template**

Spawn multiple enemies from the same template efficiently:

```rust
for i in 0..100 {
    commands.spawn((
        CharacterStats::from_data(&enemy_data),
        CharacterTemplate::new(enemy_index),
        // ... each entity: ~24 bytes of components
        // ... NOT: 100 copies of the full CharacterData
    ));
}
```

---

## File Structure After Refactoring

```
src/characters/
├── mod.rs
├── animation.rs
├── config.rs         → renamed to data.rs
├── movement.rs
├── spawn.rs
├── stats.rs          → NEW
└── template.rs       → NEW (or combine with stats.rs)
```

---

## Migration Checklist

- [ ] Create `CharacterData` struct (rename from `CharacterEntry`)
- [ ] Create `CharacterStats` component with `from_data()` constructor
- [ ] Create `CharacterTemplate` component with index reference
- [ ] Update `spawn.rs` to use new components
- [ ] Update `movement.rs` to query `CharacterStats` instead of `CharacterEntry`
- [ ] Update `animation.rs` to look up data via `CharacterTemplate` index
- [ ] Update `switch_character` to only update stats and template index
- [ ] Remove `Component` derive from `CharacterData`
- [ ] Rename `CharactersList` to `CharacterDataList` for clarity

