# Refactoring Issue #10: Massive Code Duplication in `rules.rs`

## The Problem

### Current Implementation Scale

The `rules.rs` file contains **~670 lines**, with approximately **400+ lines** being near-duplicate code across three terrain layer functions:

| Function | Lines | Purpose |
|----------|-------|---------|
| `build_grass_layer` | ~140 | Green grass tiles with corners/edges |
| `build_yellow_grass_layer` | ~130 | Yellow grass tiles with corners/edges |
| `build_water_layer` | ~145 | Water tiles with corners/edges |

Each function follows the **exact same pattern**:

```rust
// Pattern repeated in ALL THREE functions:

// 1. Void model
terrain_model_builder.create_model(
    SocketsCartesian3D::Simple { /* 6 socket values */ },
    Vec::new(),
);

// 2. Main tile
terrain_model_builder.create_model(
    SocketsCartesian3D::Simple { /* 6 socket values */ },
    vec![SpawnableAsset::new("tile_name")],
).with_weight(WEIGHT);

// 3. Outer corner template
let corner_out = SocketsCartesian3D::Simple { /* 6 socket values */ }.to_template();

// 4. Inner corner template
let corner_in = SocketsCartesian3D::Simple { /* 6 socket values */ }.to_template();

// 5. Side edge template
let side = SocketsCartesian3D::Simple { /* 6 socket values */ }.to_template();

// 6. Create 4 rotated outer corners
terrain_model_builder.create_model(corner_out.clone(), vec![SpawnableAsset::new("prefix_corner_out_tl")]);
terrain_model_builder.create_model(corner_out.rotated(Rot90, ZForward), vec![SpawnableAsset::new("prefix_corner_out_bl")]);
terrain_model_builder.create_model(corner_out.rotated(Rot180, ZForward), vec![SpawnableAsset::new("prefix_corner_out_br")]);
terrain_model_builder.create_model(corner_out.rotated(Rot270, ZForward), vec![SpawnableAsset::new("prefix_corner_out_tr")]);

// 7. Create 4 rotated inner corners (COPY-PASTE of above)
terrain_model_builder.create_model(corner_in.clone(), vec![SpawnableAsset::new("prefix_corner_in_tl")]);
terrain_model_builder.create_model(corner_in.rotated(Rot90, ZForward), vec![SpawnableAsset::new("prefix_corner_in_bl")]);
terrain_model_builder.create_model(corner_in.rotated(Rot180, ZForward), vec![SpawnableAsset::new("prefix_corner_in_br")]);
terrain_model_builder.create_model(corner_in.rotated(Rot270, ZForward), vec![SpawnableAsset::new("prefix_corner_in_tr")]);

// 8. Create 4 rotated side edges (COPY-PASTE of above)
terrain_model_builder.create_model(side.clone(), vec![SpawnableAsset::new("prefix_side_t")]);
terrain_model_builder.create_model(side.rotated(Rot90, ZForward), vec![SpawnableAsset::new("prefix_side_l")]);
terrain_model_builder.create_model(side.rotated(Rot180, ZForward), vec![SpawnableAsset::new("prefix_side_b")]);
terrain_model_builder.create_model(side.rotated(Rot270, ZForward), vec![SpawnableAsset::new("prefix_side_r")]);

// 9. Add connection rules
socket_collection.add_connections(...);
```

### What's Wrong?

#### 1. **DRY Violation (Don't Repeat Yourself)**

The rotation pattern appears **12 times** across the file:
- 4 rotations × 3 variant types (corner_out, corner_in, side)
- Repeated for grass, yellow_grass, water

That's **36 near-identical `create_model` calls**.

#### 2. **Maintenance Nightmare**

Want to add a new rotation (e.g., `Rot45` for diagonal tiles)?
- Modify 3 functions
- Add 12+ new lines each
- Copy-paste and adjust sprite names
- High chance of typos

#### 3. **Inconsistency Risk**

Subtle differences can creep in:
```rust
// In build_grass_layer:
terrain_model_builder.create_model(corner_out.clone(), ...);

// In build_water_layer - accidentally different:
terrain_model_builder.create_model(corner_out.rotated(Rot0, ZForward), ...);  // Functionally same but inconsistent
```

#### 4. **Bug Duplication**

If there's a bug in the rotation logic, it exists in 3 places. Fix it once, forget to fix it elsewhere.

#### 5. **Adding New Terrain Types is Tedious**

Want to add a `build_sand_layer` or `build_snow_layer`?
- Copy 140 lines
- Change sprite prefix throughout
- Change socket references
- Pray you didn't miss anything

#### 6. **Hidden Variation**

The duplication obscures what's actually **different** between layers:
- Socket connections
- Weights
- Sprite names

These meaningful differences are buried in boilerplate.

---

## The Solution: Template-Based Abstraction

### Core Insight

Every terrain layer with edges consists of:
1. A **void model** (empty space)
2. A **fill model** (main tile)
3. **Edge variants**: outer corners, inner corners, side edges
4. Each variant has **4 rotations**

The only differences are:
- **Socket configuration** (what connects to what)
- **Sprite prefix** (naming convention)
- **Weights** (probability of spawning)

---

## Step 1: Define a Terrain Layer Configuration

```rust
// src/map/terrain_layer.rs (NEW FILE)
use bevy_procedural_tilemaps::prelude::*;
use crate::map::assets::SpawnableAsset;

/// Configuration for a standard terrain layer with edge tiles.
pub struct TerrainLayerConfig {
    /// Sprite name prefix (e.g., "green_grass", "water")
    pub sprite_prefix: &'static str,
    
    /// Weight for the main fill tile
    pub fill_weight: f32,
    
    /// Weight for edge/corner variants (usually lower)
    pub edge_weight: Option<f32>,
    
    /// Socket configuration for this layer
    pub sockets: LayerSockets,
}

/// Socket assignments for a terrain layer
pub struct LayerSockets {
    /// Sockets for the void (empty) model
    pub void: SocketsCartesian3D,
    
    /// Sockets for the fill (main tile) model
    pub fill: SocketsCartesian3D,
    
    /// Sockets for outer corner template
    pub corner_out: SocketsCartesian3D,
    
    /// Sockets for inner corner template
    pub corner_in: SocketsCartesian3D,
    
    /// Sockets for side edge template
    pub side: SocketsCartesian3D,
}
```

---

## Step 2: Create the Rotation Helper

```rust
// src/map/terrain_layer.rs (continued)
use bevy_procedural_tilemaps::prelude::*;

/// Standard rotations for tile variants
const CORNER_ROTATIONS: [(ModelRotation, &str); 4] = [
    (ModelRotation::Rot0, "_tl"),
    (ModelRotation::Rot90, "_bl"),
    (ModelRotation::Rot180, "_br"),
    (ModelRotation::Rot270, "_tr"),
];

const SIDE_ROTATIONS: [(ModelRotation, &str); 4] = [
    (ModelRotation::Rot0, "_t"),
    (ModelRotation::Rot90, "_l"),
    (ModelRotation::Rot180, "_b"),
    (ModelRotation::Rot270, "_r"),
];

/// Creates all rotated variants of a template tile.
fn create_rotated_variants(
    builder: &mut TerrainModelBuilder,
    template: ModelTemplate<Cartesian3D>,
    sprite_prefix: &str,
    variant_name: &str,
    rotations: &[(ModelRotation, &str)],
) {
    for (rotation, suffix) in rotations {
        let rotated = if *rotation == ModelRotation::Rot0 {
            template.clone()
        } else {
            template.rotated(*rotation, Direction::ZForward)
        };
        
        let sprite_name = format!("{}{}{}", sprite_prefix, variant_name, suffix);
        // Use static string by leaking (acceptable for game startup)
        let sprite_name: &'static str = Box::leak(sprite_name.into_boxed_str());
        
        builder.create_model(rotated, vec![SpawnableAsset::new(sprite_name)]);
    }
}
```

---

## Step 3: The Main Builder Function

```rust
// src/map/terrain_layer.rs (continued)

/// Builds a complete terrain layer with void, fill, and all edge variants.
pub fn build_terrain_layer(
    builder: &mut TerrainModelBuilder,
    config: TerrainLayerConfig,
) {
    let TerrainLayerConfig {
        sprite_prefix,
        fill_weight,
        edge_weight,
        sockets,
    } = config;
    
    // 1. Void model (empty space)
    builder.create_model(sockets.void, Vec::new());
    
    // 2. Fill model (main tile)
    builder
        .create_model(
            sockets.fill,
            vec![SpawnableAsset::new(sprite_prefix)],
        )
        .with_weight(fill_weight);
    
    // 3. Create templates
    let corner_out = sockets.corner_out.to_template();
    let corner_in = sockets.corner_in.to_template();
    let side = sockets.side.to_template();
    
    // Apply edge weight if specified
    let corner_out = match edge_weight {
        Some(w) => corner_out.with_weight(w),
        None => corner_out,
    };
    let corner_in = match edge_weight {
        Some(w) => corner_in.with_weight(w),
        None => corner_in,
    };
    let side = match edge_weight {
        Some(w) => side.with_weight(w),
        None => side,
    };
    
    // 4. Create all rotated variants
    create_rotated_variants(builder, corner_out, sprite_prefix, "_corner_out", &CORNER_ROTATIONS);
    create_rotated_variants(builder, corner_in, sprite_prefix, "_corner_in", &CORNER_ROTATIONS);
    create_rotated_variants(builder, side, sprite_prefix, "_side", &SIDE_ROTATIONS);
}
```

---

## Step 4: Refactored Layer Functions

### Before: `build_grass_layer` (~140 lines)

```rust
fn build_grass_layer(
    terrain_model_builder: &mut TerrainModelBuilder,
    terrain_sockets: &TerrainSockets,
    socket_collection: &mut SocketCollection,
) {
    // 140 lines of repetitive code...
}
```

### After: `build_grass_layer` (~35 lines)

```rust
fn build_grass_layer(
    builder: &mut TerrainModelBuilder,
    sockets: &TerrainSockets,
    socket_collection: &mut SocketCollection,
) {
    build_terrain_layer(builder, TerrainLayerConfig {
        sprite_prefix: "green_grass",
        fill_weight: 5.0,
        edge_weight: None,
        sockets: LayerSockets {
            void: SocketsCartesian3D::Simple {
                x_pos: sockets.void,
                x_neg: sockets.void,
                z_pos: sockets.grass.layer_up,
                z_neg: sockets.grass.layer_down,
                y_pos: sockets.void,
                y_neg: sockets.void,
            },
            fill: SocketsCartesian3D::Multiple {
                x_pos: vec![sockets.grass.material],
                x_neg: vec![sockets.grass.material],
                z_pos: vec![sockets.grass.layer_up, sockets.grass.grass_fill_up],
                z_neg: vec![sockets.grass.layer_down],
                y_pos: vec![sockets.grass.material],
                y_neg: vec![sockets.grass.material],
            },
            corner_out: SocketsCartesian3D::Simple {
                x_pos: sockets.grass.void_and_grass,
                x_neg: sockets.void,
                z_pos: sockets.grass.layer_up,
                z_neg: sockets.grass.layer_down,
                y_pos: sockets.void,
                y_neg: sockets.grass.grass_and_void,
            },
            corner_in: SocketsCartesian3D::Simple {
                x_pos: sockets.grass.grass_and_void,
                x_neg: sockets.grass.material,
                z_pos: sockets.grass.layer_up,
                z_neg: sockets.grass.layer_down,
                y_pos: sockets.grass.material,
                y_neg: sockets.grass.void_and_grass,
            },
            side: SocketsCartesian3D::Simple {
                x_pos: sockets.grass.void_and_grass,
                x_neg: sockets.grass.grass_and_void,
                z_pos: sockets.grass.layer_up,
                z_neg: sockets.grass.layer_down,
                y_pos: sockets.void,
                y_neg: sockets.grass.material,
            },
        },
    });
    
    // Connection rules - unique to this layer
    socket_collection.add_rotated_connection(
        sockets.dirt.layer_up,
        vec![sockets.grass.layer_down],
    );
    socket_collection.add_connections(vec![
        (sockets.void, vec![sockets.void]),
        (sockets.grass.material, vec![sockets.grass.material]),
        (sockets.grass.void_and_grass, vec![sockets.grass.grass_and_void]),
    ]);
}
```

---

## Step 5: Refactored Water Layer (with Edge Weight)

```rust
fn build_water_layer(
    builder: &mut TerrainModelBuilder,
    sockets: &TerrainSockets,
    socket_collection: &mut SocketCollection,
) {
    const WATER_WEIGHT: f32 = 0.02;
    
    build_terrain_layer(builder, TerrainLayerConfig {
        sprite_prefix: "water",
        fill_weight: 10.0 * WATER_WEIGHT,
        edge_weight: Some(WATER_WEIGHT),  // Edge tiles have lower weight
        sockets: LayerSockets {
            void: SocketsCartesian3D::Multiple {
                x_pos: vec![sockets.void],
                x_neg: vec![sockets.void],
                z_pos: vec![sockets.water.layer_up, sockets.water.ground_up],
                z_neg: vec![sockets.water.layer_down],
                y_pos: vec![sockets.void],
                y_neg: vec![sockets.void],
            },
            fill: SocketsCartesian3D::Simple {
                x_pos: sockets.water.material,
                x_neg: sockets.water.material,
                z_pos: sockets.water.layer_up,
                z_neg: sockets.water.layer_down,
                y_pos: sockets.water.material,
                y_neg: sockets.water.material,
            },
            corner_out: SocketsCartesian3D::Simple {
                x_pos: sockets.water.void_and_water,
                x_neg: sockets.void,
                z_pos: sockets.water.layer_up,
                z_neg: sockets.water.layer_down,
                y_pos: sockets.void,
                y_neg: sockets.water.water_and_void,
            },
            corner_in: SocketsCartesian3D::Simple {
                x_pos: sockets.water.water_and_void,
                x_neg: sockets.water.material,
                z_pos: sockets.water.layer_up,
                z_neg: sockets.water.layer_down,
                y_pos: sockets.water.material,
                y_neg: sockets.water.void_and_water,
            },
            side: SocketsCartesian3D::Simple {
                x_pos: sockets.water.void_and_water,
                x_neg: sockets.water.water_and_void,
                z_pos: sockets.water.layer_up,
                z_neg: sockets.water.layer_down,
                y_pos: sockets.void,
                y_neg: sockets.water.material,
            },
        },
    });
    
    // Connection rules
    socket_collection.add_connections(vec![
        (sockets.water.material, vec![sockets.water.material]),
        (sockets.water.water_and_void, vec![sockets.water.void_and_water]),
    ]);
    socket_collection.add_rotated_connection(
        sockets.yellow_grass.layer_up,
        vec![sockets.water.layer_down],
    );
}
```

---

## Bonus: Props Layer Refactoring

The props layer also has repetition:

### Before

```rust
// Rocks (4 lines of repetition)
terrain_model_builder.create_model(rock_prop.clone(), vec![SpawnableAsset::new("rock_1")]);
terrain_model_builder.create_model(rock_prop.clone(), vec![SpawnableAsset::new("rock_2")]);
terrain_model_builder.create_model(rock_prop.clone(), vec![SpawnableAsset::new("rock_3")]);
terrain_model_builder.create_model(rock_prop.clone(), vec![SpawnableAsset::new("rock_4")]);

// Plants (4 lines of repetition)
terrain_model_builder.create_model(plant_prop.clone(), vec![SpawnableAsset::new("plant_1")]);
terrain_model_builder.create_model(plant_prop.clone(), vec![SpawnableAsset::new("plant_2")]);
terrain_model_builder.create_model(plant_prop.clone(), vec![SpawnableAsset::new("plant_3")]);
terrain_model_builder.create_model(plant_prop.clone(), vec![SpawnableAsset::new("plant_4")]);
```

### After

```rust
/// Creates multiple props with the same template
fn create_prop_variants(
    builder: &mut TerrainModelBuilder,
    template: ModelTemplate<Cartesian3D>,
    names: &[&'static str],
) {
    for name in names {
        builder.create_model(template.clone(), vec![SpawnableAsset::new(name)]);
    }
}

// Usage:
create_prop_variants(builder, rock_prop, &["rock_1", "rock_2", "rock_3", "rock_4"]);
create_prop_variants(builder, plant_prop, &["plant_1", "plant_2", "plant_3", "plant_4"]);
create_prop_variants(builder, stump_prop, &["tree_stump_1", "tree_stump_2", "tree_stump_3"]);
```

---

## Line Count Comparison

| Component | Before | After | Reduction |
|-----------|--------|-------|-----------|
| `build_grass_layer` | ~140 | ~40 | **-71%** |
| `build_yellow_grass_layer` | ~130 | ~40 | **-69%** |
| `build_water_layer` | ~145 | ~45 | **-69%** |
| `build_props_layer` | ~170 | ~100 | **-41%** |
| Helper functions | 0 | ~60 | +60 |
| **Total** | ~585 | ~285 | **-51%** |

Plus: vastly improved maintainability, testability, and extensibility.

---

## Design Principles Applied

### 1. **DRY (Don't Repeat Yourself)**

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

The rotation pattern now exists in exactly one place:
```rust
const CORNER_ROTATIONS: [(ModelRotation, &str); 4] = [...];
```

Change it once, applies everywhere.

### 2. **Template Method Pattern (GoF)**

> Define the skeleton of an algorithm, deferring some steps to subclasses.

`build_terrain_layer` is the template:
```
1. Create void model
2. Create fill model
3. Create edge templates
4. Generate rotated variants
```

Each layer provides its own socket configuration (the "deferred steps").

### 3. **Configuration Over Code**

The `TerrainLayerConfig` struct turns **code** into **data**:

```rust
// Before: Logic encoded in code structure
terrain_model_builder.create_model(
    SocketsCartesian3D::Simple {
        x_pos: terrain_sockets.grass.void_and_grass,
        // ...
    },
    vec![SpawnableAsset::new("green_grass_corner_out_tl")],
);

// After: Logic encoded in data structure
TerrainLayerConfig {
    sprite_prefix: "green_grass",
    sockets: LayerSockets {
        corner_out: SocketsCartesian3D::Simple {
            x_pos: sockets.grass.void_and_grass,
            // ...
        },
    },
}
```

Data is easier to validate, serialize, and generate.

### 4. **Open/Closed Principle**

> Software entities should be open for extension but closed for modification.

Adding a new terrain layer:
- **Before**: Copy 140 lines, modify throughout
- **After**: Create a new `TerrainLayerConfig`, call `build_terrain_layer`

No modification to the builder needed.

### 5. **Single Point of Truth**

Rotation definitions:
```rust
const CORNER_ROTATIONS: [(ModelRotation, &str); 4] = [
    (ModelRotation::Rot0, "_tl"),
    (ModelRotation::Rot90, "_bl"),
    (ModelRotation::Rot180, "_br"),
    (ModelRotation::Rot270, "_tr"),
];
```

This is the **authoritative** definition. Want to change `_tl` to `_top_left`? Change it in one place.

### 6. **Abstraction by Parameterization**

The helper function extracts the **pattern** and parameterizes the **variations**:

```rust
create_rotated_variants(
    builder,           // Where to add models
    template,          // What to rotate
    sprite_prefix,     // Naming convention
    variant_name,      // e.g., "_corner_out"
    rotations,         // Rotation definitions
);
```

Each parameter represents a dimension of variation.

### 7. **Locality of Change**

Related changes stay together:
- All socket definitions for a layer are in one struct
- All rotation logic is in one function
- All variant creation is in one place

### 8. **Self-Documenting Code**

The structure names explain themselves:
```rust
TerrainLayerConfig {
    sprite_prefix: "water",
    fill_weight: 0.2,
    edge_weight: Some(0.02),
    sockets: LayerSockets {
        void: ...,
        fill: ...,
        corner_out: ...,
        corner_in: ...,
        side: ...,
    },
}
```

Compare to 140 lines of `create_model` calls where you have to mentally parse what each block does.

---

## Testing Benefits

### Before: Impossible to Unit Test

```rust
// How do you test that rotations are correct?
// You'd have to run the whole game and visually inspect.
```

### After: Testable Components

```rust
#[test]
fn test_corner_rotations_coverage() {
    // Verify all 4 corners are covered
    assert_eq!(CORNER_ROTATIONS.len(), 4);
    
    let suffixes: Vec<_> = CORNER_ROTATIONS.iter().map(|(_, s)| *s).collect();
    assert!(suffixes.contains(&"_tl"));
    assert!(suffixes.contains(&"_tr"));
    assert!(suffixes.contains(&"_bl"));
    assert!(suffixes.contains(&"_br"));
}

#[test]
fn test_rotation_progression() {
    // Verify rotations are sequential
    let rotations: Vec<_> = CORNER_ROTATIONS.iter().map(|(r, _)| *r).collect();
    assert_eq!(rotations[0], ModelRotation::Rot0);
    assert_eq!(rotations[1], ModelRotation::Rot90);
    assert_eq!(rotations[2], ModelRotation::Rot180);
    assert_eq!(rotations[3], ModelRotation::Rot270);
}

#[test]
fn test_sprite_name_generation() {
    let name = format!("{}{}{}", "water", "_corner_out", "_tl");
    assert_eq!(name, "water_corner_out_tl");
}
```

---

## Future Extensibility

### Adding a Sand Layer

```rust
fn build_sand_layer(
    builder: &mut TerrainModelBuilder,
    sockets: &TerrainSockets,
    socket_collection: &mut SocketCollection,
) {
    build_terrain_layer(builder, TerrainLayerConfig {
        sprite_prefix: "sand",
        fill_weight: 8.0,
        edge_weight: None,
        sockets: LayerSockets {
            // Just define the sockets - all rotation logic is handled!
            void: SocketsCartesian3D::Simple { ... },
            fill: SocketsCartesian3D::Simple { ... },
            corner_out: SocketsCartesian3D::Simple { ... },
            corner_in: SocketsCartesian3D::Simple { ... },
            side: SocketsCartesian3D::Simple { ... },
        },
    });
    
    socket_collection.add_connections(...);
}
```

### Adding Diagonal Tiles

If the tileset expands to include diagonal transitions:

```rust
// Just add to the rotation definitions
const DIAGONAL_ROTATIONS: [(ModelRotation, &str); 4] = [
    (ModelRotation::Rot0, "_ne"),
    (ModelRotation::Rot90, "_se"),
    (ModelRotation::Rot180, "_sw"),
    (ModelRotation::Rot270, "_nw"),
];

// And call:
create_rotated_variants(builder, diagonal, sprite_prefix, "_diagonal", &DIAGONAL_ROTATIONS);
```

No changes to any existing terrain layer functions!

### Data-Driven Terrain

With the config struct, terrain could even be loaded from files:

```ron
// terrain_layers.ron (hypothetical)
[
    (
        sprite_prefix: "green_grass",
        fill_weight: 5.0,
        edge_weight: None,
        layer_type: Grass,
    ),
    (
        sprite_prefix: "water",
        fill_weight: 0.2,
        edge_weight: Some(0.02),
        layer_type: Water,
    ),
]
```

---

## Migration Checklist

- [ ] Create `terrain_layer.rs` module
- [ ] Define `TerrainLayerConfig` and `LayerSockets` structs
- [ ] Define rotation constants (`CORNER_ROTATIONS`, `SIDE_ROTATIONS`)
- [ ] Implement `create_rotated_variants` helper
- [ ] Implement `build_terrain_layer` function
- [ ] Refactor `build_grass_layer` to use new system
- [ ] Verify grass layer works correctly (visual test)
- [ ] Refactor `build_yellow_grass_layer`
- [ ] Refactor `build_water_layer`
- [ ] Refactor `build_props_layer` with `create_prop_variants`
- [ ] Remove old duplicate code
- [ ] Add unit tests for rotation/naming logic
- [ ] Update module exports in `map/mod.rs`

---

## File Structure After Refactoring

```
src/map/
├── mod.rs
├── assets.rs
├── generate.rs
├── models.rs
├── rules.rs            → Simplified, uses terrain_layer
├── terrain_layer.rs    → NEW: TerrainLayerConfig, helpers
├── sockets.rs
└── tilemap.rs
```

### Final `rules.rs` Structure

```rust
// rules.rs - Now ~200 lines instead of ~670

mod terrain_layer;
use terrain_layer::{build_terrain_layer, TerrainLayerConfig, LayerSockets};

fn build_dirt_layer(...) { /* ~25 lines - unchanged, simple */ }

fn build_grass_layer(...) {
    build_terrain_layer(builder, TerrainLayerConfig { ... });
    socket_collection.add_connections(...);
}

fn build_yellow_grass_layer(...) {
    build_terrain_layer(builder, TerrainLayerConfig { ... });
    socket_collection.add_rotated_connection(...);
}

fn build_water_layer(...) {
    build_terrain_layer(builder, TerrainLayerConfig { ... });
    socket_collection.add_connections(...);
}

fn build_props_layer(...) {
    // Void model
    builder.create_model(...);
    
    // Use helper for props
    create_prop_variants(builder, rock_prop, &["rock_1", "rock_2", "rock_3", "rock_4"]);
    create_prop_variants(builder, plant_prop, &["plant_1", "plant_2", "plant_3", "plant_4"]);
    // ... trees handled separately due to multi-tile nature
    
    socket_collection.add_connections(...);
}

pub fn build_world() -> (...) {
    // Unchanged orchestration logic
}
```

