# Refactoring Issue #6: Fragile Animation State Tracking

## The Problem

### Current Implementation

```rust
// src/characters/animation.rs
#[derive(Component, Default)]
pub struct AnimationState {
    pub is_moving: bool,
    pub was_moving: bool,
    pub is_jumping: bool,
    pub was_jumping: bool,
}
```

With a separate synchronization system that must run at the correct time:

```rust
// src/characters/animation.rs
pub fn update_animation_flags(mut query: Query<&mut AnimationState>) {
    for mut state in query.iter_mut() {
        state.was_moving = state.is_moving;
        state.was_jumping = state.is_jumping;
    }
}
```

### What's Wrong?

#### 1. **Temporal Coupling / Order Dependency**

The system only works correctly if `update_animation_flags` runs at exactly the right time - after all systems that read the "just changed" state, but before the next frame's state updates.

```rust
// In CharactersPlugin - order matters!
.add_systems(Update, (
    movement::move_player,
    movement::update_jump_state,
    animation::animate_characters,
    animation::update_animation_flags,  // Must be LAST!
))
```

If a new developer adds a system that depends on state transitions but schedules it after `update_animation_flags`, it will silently fail.

#### 2. **Duplicated Logic Pattern**

Every boolean state requires tracking both `is_X` and `was_X`:

```rust
pub is_moving: bool,
pub was_moving: bool,
pub is_jumping: bool,
pub was_jumping: bool,
// Adding a new state? Need TWO more fields:
// pub is_attacking: bool,
// pub was_attacking: bool,
```

#### 3. **Scattered Transition Detection**

The transition logic is computed wherever it's needed:

```rust
// animate_characters system
let just_started_moving = state.is_moving && !state.was_moving;
let just_stopped_moving = !state.is_moving && state.was_moving;
let just_started_jumping = state.is_jumping && !state.was_jumping;
let just_stopped_jumping = !state.is_jumping && state.was_jumping;
```

This same logic would need to be duplicated in any other system that cares about transitions.

#### 4. **Invalid State Combinations**

Nothing prevents illogical states:

```rust
// Is this valid? Can you be jumping while not moving?
state.is_moving = false;
state.is_jumping = true;

// What about this? Was moving but now jumping?
state.is_moving = false;
state.was_moving = true;
state.is_jumping = true;
state.was_jumping = false;
```

The boolean soup makes it hard to reason about valid state combinations.

#### 5. **Not Leveraging Bevy's ECS**

Bevy has built-in change detection (`Changed<T>`, `Added<T>`) specifically designed to handle "what just changed" scenarios. The manual tracking reinvents this wheel, poorly.

---

## Solution A: Bevy's Change Detection

### Use `Changed<T>` Query Filter

Bevy tracks component changes automatically. We can simplify to:

```rust
// src/characters/state.rs
#[derive(Component, Default, Debug, Clone, Copy, PartialEq, Eq)]
pub struct MovementState {
    pub is_moving: bool,
    pub is_running: bool,
}

#[derive(Component, Default, Debug, Clone, Copy, PartialEq, Eq)]
pub struct JumpState {
    pub is_jumping: bool,
}
```

Then detect changes with queries:

```rust
pub fn on_movement_changed(
    query: Query<(Entity, &MovementState), Changed<MovementState>>,
) {
    for (entity, movement) in query.iter() {
        // This only runs when MovementState actually changed!
        if movement.is_moving {
            info!("Entity {:?} started moving", entity);
        } else {
            info!("Entity {:?} stopped moving", entity);
        }
    }
}
```

### Benefits of `Changed<T>`

1. **No manual synchronization** - Bevy handles the "previous vs current" tracking
2. **Automatic efficiency** - Query only iterates entities that actually changed
3. **Correct by construction** - No ordering bugs possible

### Limitations of `Changed<T>`

1. **Only detects that change happened, not what changed from** - You know it changed, but not the previous value
2. **Runs once per change** - If state changes multiple times in one frame, you only see the final state
3. **Frame-boundary semantics** - Change is detected on the frame after mutation

---

## Solution B: State Machine Enum (Recommended)

A proper state machine eliminates invalid states and makes transitions explicit.

### Core State Enum

```rust
// src/characters/state.rs
use bevy::prelude::*;

/// Mutually exclusive character states.
/// A character can only be in ONE of these states at a time.
#[derive(Component, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum CharacterState {
    #[default]
    Idle,
    Walking,
    Running,
    Jumping,
    // Future states:
    // Attacking,
    // Stunned,
    // Dead,
}

impl CharacterState {
    /// Check if character should be animating (not idle)
    pub fn is_animating(&self) -> bool {
        !matches!(self, CharacterState::Idle)
    }
    
    /// Check if character is in any movement state
    pub fn is_moving(&self) -> bool {
        matches!(self, CharacterState::Walking | CharacterState::Running)
    }
    
    /// Check if this is a grounded state (can jump from here)
    pub fn is_grounded(&self) -> bool {
        matches!(self, CharacterState::Idle | CharacterState::Walking | CharacterState::Running)
    }
}
```

### Previous State Tracking (If Needed)

If you genuinely need to know the previous state for transition logic:

```rust
/// Tracks state transitions for animation blending and effects.
#[derive(Component, Debug, Clone, Copy)]
pub struct StateTransition {
    pub previous: CharacterState,
    pub current: CharacterState,
    pub changed_at: f32,  // Time when transition occurred
}

impl StateTransition {
    pub fn new(initial: CharacterState) -> Self {
        Self {
            previous: initial,
            current: initial,
            changed_at: 0.0,
        }
    }
    
    /// Update state, returns true if state actually changed
    pub fn set(&mut self, new_state: CharacterState, time: f32) -> bool {
        if self.current != new_state {
            self.previous = self.current;
            self.current = new_state;
            self.changed_at = time;
            true
        } else {
            false
        }
    }
    
    /// Check if we just transitioned from one state to another
    pub fn just_transitioned(&self, from: CharacterState, to: CharacterState) -> bool {
        self.previous == from && self.current == to
    }
    
    /// Time spent in current state
    pub fn time_in_state(&self, current_time: f32) -> f32 {
        current_time - self.changed_at
    }
}
```

### Combining with `Changed<T>`

Best of both worlds - use the enum for state, and Bevy's change detection for reactions:

```rust
pub fn react_to_state_changes(
    time: Res<Time>,
    mut query: Query<
        (Entity, &CharacterState, &mut AnimationController),
        Changed<CharacterState>
    >,
) {
    for (entity, state, mut animation) in query.iter_mut() {
        // This only runs when CharacterState changes!
        match state {
            CharacterState::Idle => {
                animation.current_animation = AnimationType::Walk;
                // Walk animation frame 0 = idle pose
            }
            CharacterState::Walking => {
                animation.current_animation = AnimationType::Walk;
            }
            CharacterState::Running => {
                animation.current_animation = AnimationType::Run;
            }
            CharacterState::Jumping => {
                animation.current_animation = AnimationType::Jump;
            }
        }
    }
}
```

---

## Refactored Movement System

### Before

```rust
pub fn move_player(
    input: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(
        &mut Transform, 
        &mut AnimationController,
        &mut AnimationState,  // Fragile dual-bool tracking
        &CharacterEntry,
    ), With<Player>>,
) {
    // ... complex logic setting is_moving, is_jumping, 
    //     and manually managing current_animation
}
```

### After

```rust
pub fn move_player(
    input: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(
        &mut Transform,
        &mut CharacterState,
        &CharacterStats,
    ), With<Player>>,
) {
    let Ok((mut transform, mut state, stats)) = query.single_mut() else {
        return;
    };
    
    let direction = read_movement_input(&input);
    let is_running = input.pressed(KeyCode::ShiftLeft) || input.pressed(KeyCode::ShiftRight);
    let wants_jump = input.just_pressed(KeyCode::Space);
    
    // State machine transition logic
    let new_state = match *state {
        CharacterState::Jumping => {
            // Stay jumping until animation completes (handled elsewhere)
            CharacterState::Jumping
        }
        _ if wants_jump && state.is_grounded() => {
            CharacterState::Jumping
        }
        _ if direction != Vec2::ZERO => {
            if is_running {
                CharacterState::Running
            } else {
                CharacterState::Walking
            }
        }
        _ => CharacterState::Idle,
    };
    
    // Single assignment - Bevy tracks the change automatically
    *state = new_state;
    
    // Movement only if in a moving state
    if state.is_moving() {
        let speed = if is_running {
            stats.base_move_speed * stats.run_speed_multiplier
        } else {
            stats.base_move_speed
        };
        let delta = direction.normalize() * speed * time.delta_secs();
        transform.translation += delta.extend(0.0);
    }
}
```

---

## Refactored Animation System

### Before

```rust
pub fn animate_characters(
    time: Res<Time>,
    mut query: Query<(
        &AnimationController,
        &AnimationState,
        &mut AnimationTimer,
        &mut Sprite,
        &CharacterEntry,
    )>,
) {
    for (animated, state, mut timer, mut sprite, config) in query.iter_mut() {
        // Manual transition detection
        let just_started_moving = state.is_moving && !state.was_moving;
        let just_stopped_moving = !state.is_moving && state.was_moving;
        let just_started_jumping = state.is_jumping && !state.was_jumping;
        let just_stopped_jumping = !state.is_jumping && state.was_jumping;
        
        let should_animate = state.is_jumping || state.is_moving;
        let animation_changed = just_started_moving || just_started_jumping 
                              || just_stopped_moving || just_stopped_jumping;
        // ... complex branching
    }
}

// Required cleanup system
pub fn update_animation_flags(mut query: Query<&mut AnimationState>) {
    for mut state in query.iter_mut() {
        state.was_moving = state.is_moving;
        state.was_jumping = state.is_jumping;
    }
}
```

### After

```rust
/// Handles animation selection when state changes.
/// Only runs for entities whose CharacterState just changed.
pub fn on_state_change_update_animation(
    mut query: Query<
        (&CharacterState, &mut AnimationController, &mut AnimationTimer),
        Changed<CharacterState>
    >,
) {
    for (state, mut controller, mut timer) in query.iter_mut() {
        // Select animation based on new state
        controller.current_animation = match state {
            CharacterState::Idle | CharacterState::Walking => AnimationType::Walk,
            CharacterState::Running => AnimationType::Run,
            CharacterState::Jumping => AnimationType::Jump,
        };
        
        // Reset timer for fresh animation start
        timer.reset();
    }
}

/// Advances animation frames for all animated entities.
/// Separate from state change handling for clarity.
pub fn tick_animations(
    time: Res<Time>,
    character_data: Res<Assets<CharacterDataList>>,
    data_list_res: Res<CharacterDataListResource>,
    mut query: Query<(
        &CharacterState,
        &CharacterTemplate,
        &AnimationController,
        &mut AnimationTimer,
        &mut Sprite,
    )>,
) {
    let Some(data_list) = character_data.get(&data_list_res.handle) else { return };
    
    for (state, template, controller, mut timer, mut sprite) in query.iter_mut() {
        // Don't animate when idle
        if *state == CharacterState::Idle {
            continue;
        }
        
        timer.tick(time.delta());
        
        if timer.just_finished() {
            let data = &data_list.characters[template.index];
            if let Some(clip) = controller.get_clip(data) {
                if let Some(atlas) = sprite.texture_atlas.as_mut() {
                    atlas.index = clip.next(atlas.index);
                }
            }
        }
    }
}

// NO update_animation_flags SYSTEM NEEDED!
```

---

## Design Principles Applied

### 1. **State Pattern (GoF)**

> Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

The enum-based state machine encapsulates state-specific behavior:

```rust
impl CharacterState {
    pub fn is_grounded(&self) -> bool {
        matches!(self, CharacterState::Idle | CharacterState::Walking | CharacterState::Running)
    }
}
```

Each state knows its own properties without external if-else chains.

### 2. **Make Illegal States Unrepresentable**

A fundamental Rust principle: use the type system to prevent invalid states.

| Before (Booleans) | After (Enum) |
|-------------------|--------------|
| `is_moving = true, is_jumping = true` - valid? | `CharacterState::Jumping` - one state, clear meaning |
| `was_moving = true, is_moving = false, was_jumping = false, is_jumping = true` - ??? | State machine handles transitions explicitly |

With booleans, you have 2^4 = 16 possible combinations, most of which are meaningless. With an enum, you have exactly 4 valid states.

### 3. **Single Source of Truth**

```rust
// Before: Truth split between is_moving and current_animation
state.is_moving = true;
controller.current_animation = AnimationType::Walk;  // Must be kept in sync!

// After: CharacterState is the single source
*state = CharacterState::Walking;  // Animation system reacts to this
```

### 4. **Command-Query Separation (CQS)**

> Methods should either change state OR return information, not both.

Before, systems both queried and modified the same flags within complex conditionals. After:

- `move_player` - **Command**: Changes `CharacterState`
- `on_state_change_update_animation` - **Reaction**: Observes changes, updates animation
- `tick_animations` - **Query + Command**: Reads state, advances frames

### 5. **Tell, Don't Ask**

Instead of asking about multiple boolean flags to determine what to do:

```rust
// Before: Asking
if state.is_moving && !state.was_moving { ... }
if !state.is_moving && state.was_moving { ... }
if state.is_jumping && !state.was_jumping { ... }
```

The state tells you what it is:

```rust
// After: Telling
match state {
    CharacterState::Walking => { ... }
    CharacterState::Jumping => { ... }
}
```

### 6. **Leverage Framework Capabilities**

Bevy provides `Changed<T>` specifically for reactive systems. Using it:

- **Reduces boilerplate** - No manual previous/current tracking
- **Improves performance** - Only iterates changed entities
- **Guarantees correctness** - Framework-managed change detection

### 7. **Cohesion Over Coupling**

The refactored design has high cohesion (each system does one thing) and low coupling (systems communicate through shared state, not direct calls):

```
┌─────────────────┐
│   move_player   │──── writes ────▶ CharacterState
└─────────────────┘
                                          │
                                   Changed<CharacterState>
                                          │
                                          ▼
                          ┌────────────────────────────────┐
                          │ on_state_change_update_animation │
                          └────────────────────────────────┘
                                          │
                                   writes │
                                          ▼
                               AnimationController
                                          │
                                   reads  │
                                          ▼
                          ┌────────────────────────────────┐
                          │       tick_animations          │
                          └────────────────────────────────┘
```

### 8. **Fail-Fast / Compile-Time Safety**

Adding a new state with booleans requires remembering to:
1. Add `is_new_state` field
2. Add `was_new_state` field  
3. Update all transition detection logic
4. Update the sync system

With an enum, the compiler enforces exhaustive matching:

```rust
match state {
    CharacterState::Idle => { ... }
    CharacterState::Walking => { ... }
    CharacterState::Running => { ... }
    CharacterState::Jumping => { ... }
    // Add CharacterState::Attacking and compiler errors here!
}
```

---

## Extended Example: Adding Attack State

### Before (Boolean Approach)

```rust
// 1. Modify AnimationState
pub struct AnimationState {
    pub is_moving: bool,
    pub was_moving: bool,
    pub is_jumping: bool,
    pub was_jumping: bool,
    pub is_attacking: bool,   // NEW
    pub was_attacking: bool,  // NEW
}

// 2. Update sync system
pub fn update_animation_flags(mut query: Query<&mut AnimationState>) {
    for mut state in query.iter_mut() {
        state.was_moving = state.is_moving;
        state.was_jumping = state.is_jumping;
        state.was_attacking = state.is_attacking;  // EASY TO FORGET!
    }
}

// 3. Update all transition detection (everywhere!)
let just_started_attacking = state.is_attacking && !state.was_attacking;
let just_stopped_attacking = !state.is_attacking && state.was_attacking;

// 4. What if attacking while jumping? Moving while attacking?
// Boolean combinations explode!
```

### After (State Machine)

```rust
// 1. Add variant to enum
#[derive(Component, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum CharacterState {
    #[default]
    Idle,
    Walking,
    Running,
    Jumping,
    Attacking,  // NEW - just one line!
}

// 2. Add to match (compiler enforces this!)
match state {
    CharacterState::Idle => AnimationType::Walk,
    CharacterState::Walking => AnimationType::Walk,
    CharacterState::Running => AnimationType::Run,
    CharacterState::Jumping => AnimationType::Jump,
    CharacterState::Attacking => AnimationType::Attack,  // Compiler error if missing!
}

// 3. That's it! Changed<CharacterState> handles transitions automatically.
```

---

## Migration Checklist

- [ ] Create `CharacterState` enum with `Idle`, `Walking`, `Running`, `Jumping` variants
- [ ] Add helper methods (`is_moving()`, `is_grounded()`, `is_animating()`)
- [ ] Replace `AnimationState` component with `CharacterState`
- [ ] Update `move_player` to set `CharacterState` directly
- [ ] Create `on_state_change_update_animation` system using `Changed<CharacterState>`
- [ ] Simplify `animate_characters` to just tick frames (rename to `tick_animations`)
- [ ] Remove `update_animation_flags` system entirely
- [ ] Update plugin system registration (remove ordering dependency)
- [ ] Update `Facing` to be separate from state (it's orthogonal - you can face left while idle)

---

## File Structure After Refactoring

```
src/characters/
├── mod.rs
├── animation.rs      → simplified, just frame advancement
├── state.rs          → NEW: CharacterState enum and transitions
├── movement.rs       → simplified, just sets CharacterState
├── config.rs
└── spawn.rs
```

