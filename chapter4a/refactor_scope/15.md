# Refactoring Issue #15: Inconsistent Function Signatures in `assets.rs`

## The Problem

### Current Implementation

```rust
// src/map/assets.rs
pub fn prepare_tilemap_handles(
    asset_server: &Res<AssetServer>,                          // Borrowed Res
    atlas_layouts: &mut ResMut<Assets<TextureAtlasLayout>>,   // Mutable borrowed ResMut
    assets_directory: &str,
    tilemap_file: &str,
) -> TilemapHandles {
    let image = asset_server.load::<Image>(format!("{assets_directory}/{tilemap_file}"));
    let mut layout = TextureAtlasLayout::new_empty(TILEMAP.atlas_size());
    for index in 0..TILEMAP.sprites.len() {
        layout.add_texture(TILEMAP.sprite_rect(index));
    }
    let layout = atlas_layouts.add(layout);

    TilemapHandles { image, layout }
}
```

### What's Wrong?

#### 1. **Mixing Wrapper Types with Inner Types**

The signature mixes:
- `&Res<T>` - A reference to Bevy's read-only resource wrapper
- `&mut ResMut<T>` - A mutable reference to Bevy's mutable resource wrapper
- `&str` - A simple borrowed string (inner type)

This is inconsistent - why use the wrappers for some parameters but not others?

#### 2. **Unnecessary Wrapper Leakage**

`Res<T>` and `ResMut<T>` are Bevy's **system parameter** types. They:
- Implement `Deref` to access the inner `T`
- Are designed to be used in system function signatures
- Carry ECS access metadata

When passing to helper functions, the wrapper provides no benefit - you only need access to `T`.

#### 3. **Awkward Calling Syntax**

```rust
// In setup_generator system:
let tilemap_handles = prepare_tilemap_handles(
    &asset_server,       // Pass reference to Res
    &mut atlas_layouts,  // Pass mutable reference to ResMut
    ASSETS_PATH,
    TILEMAP_FILE,
);
```

The caller must remember which parameters need `&` vs `&mut`.

#### 4. **Testing Difficulty**

To test `prepare_tilemap_handles`, you need to construct `Res<AssetServer>` and `ResMut<Assets<...>>`, which requires setting up a Bevy `World`. 

If it just took `&AssetServer` and `&mut Assets<...>`, testing would be simpler.

#### 5. **Viral Wrapper Types**

If another function calls this helper, it also needs to deal with the wrapper types:

```rust
fn some_other_helper(
    asset_server: &Res<AssetServer>,        // Forced to use wrapper
    atlas_layouts: &mut ResMut<Assets<TextureAtlasLayout>>,  // Forced to use wrapper
) {
    prepare_tilemap_handles(asset_server, atlas_layouts, ...);
}
```

The wrapper types "infect" the entire call chain.

---

## Understanding Bevy's Type Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     BEVY SYSTEM PARAMETERS                       â”‚
â”‚                                                                  â”‚
â”‚   Res<T>              ResMut<T>           Query<Q, F>           â”‚
â”‚     â”‚                     â”‚                   â”‚                  â”‚
â”‚     â”‚ Deref               â”‚ Deref             â”‚                  â”‚
â”‚     â”‚ DerefMut            â”‚ DerefMut          â”‚                  â”‚
â”‚     â–¼                     â–¼                   â–¼                  â”‚
â”‚    &T                   &mut T            Iterator<Item=(...)>  â”‚
â”‚                                                                  â”‚
â”‚   These are "smart wrappers" for ECS resource access            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ Helper functions should use
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     INNER TYPES                                  â”‚
â”‚                                                                  â”‚
â”‚   &AssetServer         &mut Assets<T>        Specific structs   â”‚
â”‚                                                                  â”‚
â”‚   Plain Rust references - no Bevy dependency in signature       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## The Solution

### Option A: Use Inner Types (Recommended)

Pass references to the inner types, not the Bevy wrappers.

```rust
// src/map/assets.rs

/// Prepares tilemap handles by loading the image and creating the atlas layout.
pub fn prepare_tilemap_handles(
    asset_server: &AssetServer,                    // Inner type, read-only
    atlas_layouts: &mut Assets<TextureAtlasLayout>, // Inner type, mutable
    assets_directory: &str,
    tilemap_file: &str,
) -> TilemapHandles {
    let image = asset_server.load::<Image>(format!("{assets_directory}/{tilemap_file}"));
    
    let mut layout = TextureAtlasLayout::new_empty(TILEMAP.atlas_size());
    for index in 0..TILEMAP.sprites.len() {
        layout.add_texture(TILEMAP.sprite_rect(index));
    }
    let layout = atlas_layouts.add(layout);

    TilemapHandles { image, layout }
}
```

**Calling from a system:**

```rust
// In generate.rs
pub fn setup_generator(
    mut commands: Commands,
    asset_server: Res<AssetServer>,                           // System parameter
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,    // System parameter
) {
    // Deref happens automatically via &* or just &
    let tilemap_handles = prepare_tilemap_handles(
        &asset_server,        // &Res<T> auto-derefs to &T
        &mut atlas_layouts,   // &mut ResMut<T> auto-derefs to &mut T
        ASSETS_PATH,
        TILEMAP_FILE,
    );
    // ...
}
```

**Note:** Thanks to `Deref`, the calling code looks almost identical! Rust automatically dereferences `&Res<T>` to `&T` when the function expects `&T`.

---

### Option B: Method on a Builder Struct

For more complex setup, use a builder pattern.

```rust
// src/map/assets.rs

pub struct TilemapBuilder<'a> {
    asset_server: &'a AssetServer,
    atlas_layouts: &'a mut Assets<TextureAtlasLayout>,
}

impl<'a> TilemapBuilder<'a> {
    pub fn new(
        asset_server: &'a AssetServer,
        atlas_layouts: &'a mut Assets<TextureAtlasLayout>,
    ) -> Self {
        Self { asset_server, atlas_layouts }
    }
    
    pub fn build_tilemap(
        &mut self,
        assets_directory: &str,
        tilemap_file: &str,
    ) -> TilemapHandles {
        let image = self.asset_server.load::<Image>(
            format!("{assets_directory}/{tilemap_file}")
        );
        
        let mut layout = TextureAtlasLayout::new_empty(TILEMAP.atlas_size());
        for index in 0..TILEMAP.sprites.len() {
            layout.add_texture(TILEMAP.sprite_rect(index));
        }
        let layout = self.atlas_layouts.add(layout);

        TilemapHandles { image, layout }
    }
}
```

**Usage:**

```rust
pub fn setup_generator(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
) {
    let mut builder = TilemapBuilder::new(&asset_server, &mut atlas_layouts);
    let tilemap_handles = builder.build_tilemap(ASSETS_PATH, TILEMAP_FILE);
    // Could call builder.build_tilemap() again for other tilemaps
}
```

---

### Option C: Extension Trait (Advanced)

For very Bevy-idiomatic code, use an extension trait.

```rust
// src/map/assets.rs

pub trait TilemapHandlesExt {
    fn prepare_tilemap(
        &mut self,
        asset_server: &AssetServer,
        assets_directory: &str,
        tilemap_file: &str,
    ) -> TilemapHandles;
}

impl TilemapHandlesExt for Assets<TextureAtlasLayout> {
    fn prepare_tilemap(
        &mut self,
        asset_server: &AssetServer,
        assets_directory: &str,
        tilemap_file: &str,
    ) -> TilemapHandles {
        let image = asset_server.load::<Image>(
            format!("{assets_directory}/{tilemap_file}")
        );
        
        let mut layout = TextureAtlasLayout::new_empty(TILEMAP.atlas_size());
        for index in 0..TILEMAP.sprites.len() {
            layout.add_texture(TILEMAP.sprite_rect(index));
        }
        let layout = self.add(layout);

        TilemapHandles { image, layout }
    }
}
```

**Usage:**

```rust
pub fn setup_generator(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
) {
    let tilemap_handles = atlas_layouts.prepare_tilemap(
        &asset_server,
        ASSETS_PATH,
        TILEMAP_FILE,
    );
}
```

---

## Comparison of Approaches

| Aspect | Current | Option A (Inner Types) | Option B (Builder) | Option C (Extension) |
|--------|---------|------------------------|--------------------|--------------------|
| **Simplicity** | Medium | High | Medium | Medium |
| **Consistency** | Low | High | High | High |
| **Testability** | Low | High | High | High |
| **Bevy Coupling** | High | Low | Low | Medium |
| **Reusability** | Low | High | High | Medium |
| **Lines Changed** | - | ~5 | ~20 | ~20 |

**Recommendation:** **Option A (Inner Types)** for this case - it's the simplest fix with the most benefit.

---

## The `load_assets` Function

The same pattern applies to the other function in `assets.rs`:

### Before

```rust
pub fn load_assets(
    tilemap_handles: &TilemapHandles,      // âœ“ Already correct (inner type)
    assets_definitions: Vec<Vec<SpawnableAsset>>,  // âœ“ Already correct
) -> ModelsAssets<Sprite> {
    // ...
}
```

This function is already using the right pattern! It takes:
- `&TilemapHandles` - a reference to a plain struct
- `Vec<Vec<SpawnableAsset>>` - owned data

No Bevy wrapper types in sight. Consistent and clean.

---

## Applying the Pattern Project-Wide

Look for other places where Bevy wrappers might be leaking into helper functions:

### `spawn.rs` - `create_character_atlas_layout`

```rust
// Before
fn create_character_atlas_layout(
    atlas_layouts: &mut ResMut<Assets<TextureAtlasLayout>>,  // âŒ Wrapper type
    character_entry: &CharacterEntry,
) -> Handle<TextureAtlasLayout> {
    // ...
}

// After
fn create_character_atlas_layout(
    atlas_layouts: &mut Assets<TextureAtlasLayout>,  // âœ“ Inner type
    character_entry: &CharacterEntry,
) -> Handle<TextureAtlasLayout> {
    // ...
}
```

---

## Design Principles Applied

### 1. **Dependency Inversion Principle (DIP)**

> High-level modules should not depend on low-level modules. Both should depend on abstractions.

`Res<T>` and `ResMut<T>` are Bevy's low-level ECS primitives. Helper functions should depend on the abstract `&T` or `&mut T`, not the Bevy-specific wrappers.

```rust
// Before: Depends on Bevy's ResMut wrapper
fn helper(x: &mut ResMut<Assets<T>>) { ... }

// After: Depends on abstract mutable reference
fn helper(x: &mut Assets<T>) { ... }
```

### 2. **Interface Segregation Principle (ISP)**

> Clients should not be forced to depend on interfaces they do not use.

`Res<T>` provides:
- `Deref` to `T`
- ECS change detection metadata
- System parameter integration

A helper function only needs `&T` - it shouldn't be forced to accept the full `Res<T>` interface.

### 3. **Separation of Concerns**

- **System functions**: Deal with ECS, use `Res<T>`, `ResMut<T>`, `Query<...>`
- **Helper functions**: Deal with business logic, use plain Rust types

This separation makes helpers:
- Testable without Bevy's ECS
- Reusable outside of systems
- Easier to understand

### 4. **Principle of Least Knowledge (Law of Demeter)**

> A module should not know about the inner workings of objects it manipulates.

The helper doesn't need to know it's receiving a Bevy resource wrapper. It just needs access to an `AssetServer`.

```rust
// Before: Knows about Res wrapper
fn helper(asset_server: &Res<AssetServer>) {
    asset_server.load(...);  // Works via Deref, but why expose the wrapper?
}

// After: Knows only about AssetServer
fn helper(asset_server: &AssetServer) {
    asset_server.load(...);  // Direct, no wrapper knowledge needed
}
```

### 5. **Consistency**

The current code mixes patterns:
- `&Res<AssetServer>` - borrowed wrapper
- `&mut ResMut<Assets<...>>` - mutably borrowed wrapper
- `&str` - borrowed inner type

Pick one approach and stick with it. The inner type approach is more consistent with Rust conventions.

### 6. **Testability**

```rust
// Testing with wrapper types - needs full Bevy setup
#[test]
fn test_prepare_tilemap() {
    let mut app = App::new();
    app.add_plugins(MinimalPlugins);
    app.add_plugins(AssetPlugin::default());
    // ... lots of setup ...
    
    let world = app.world();
    let asset_server = world.resource::<AssetServer>();
    // Create Res<AssetServer> somehow... ğŸ˜°
}

// Testing with inner types - simple mock/real instances
#[test]
fn test_prepare_tilemap() {
    let asset_server = AssetServer::new(...);
    let mut atlas_layouts = Assets::<TextureAtlasLayout>::default();
    
    let handles = prepare_tilemap_handles(
        &asset_server,
        &mut atlas_layouts,
        "test_assets",
        "test.png",
    );
    
    assert!(handles.image.id() != AssetId::invalid());
}
```

### 7. **Idiomatic Rust**

Rust functions typically take references to values, not references to smart pointers:

```rust
// Non-idiomatic
fn process(data: &Box<Vec<i32>>) { ... }
fn process(data: &Rc<Config>) { ... }
fn process(data: &Res<AssetServer>) { ... }

// Idiomatic
fn process(data: &[i32]) { ... }
fn process(data: &Config) { ... }
fn process(data: &AssetServer) { ... }
```

Let the caller handle the smart pointer; the function works with the content.

---

## Anti-Pattern: Wrapper Type Virality

### The Problem

Once you use wrapper types in helper signatures, they spread:

```rust
// Level 1: Helper uses wrapper
fn helper_a(res: &Res<MyResource>) { ... }

// Level 2: Another helper calls helper_a, must also use wrapper
fn helper_b(res: &Res<MyResource>) {
    helper_a(res);  // Must pass wrapper
}

// Level 3: And again...
fn helper_c(res: &Res<MyResource>) {
    helper_b(res);
}

// Eventually your entire codebase is infected with Res/ResMut
```

### The Solution

Stop the spread at the system boundary:

```rust
// System: Uses wrappers (required by Bevy)
fn my_system(res: Res<MyResource>) {
    // Dereference at the boundary
    helper_a(&res);  // Passes &MyResource
}

// Helpers: Use inner types
fn helper_a(res: &MyResource) {
    helper_b(res);  // Clean reference passing
}

fn helper_b(res: &MyResource) {
    helper_c(res);  // No wrapper types anywhere
}

fn helper_c(res: &MyResource) {
    // Pure business logic
}
```

---

## Complete Refactored Code

```rust
// src/map/assets.rs
use bevy::{prelude::*, sprite::Anchor};
use bevy_procedural_tilemaps::prelude::*;
use crate::map::tilemap::TILEMAP;

#[derive(Clone)]
pub struct SpawnableAsset {
    sprite_name: &'static str,
    grid_offset: GridDelta,
    offset: Vec3,
    components_spawner: fn(&mut EntityCommands),
}

impl SpawnableAsset {
    pub fn new(sprite_name: &'static str) -> Self {
        Self {
            sprite_name,
            grid_offset: GridDelta::new(0, 0, 0),
            offset: Vec3::ZERO,
            components_spawner: |_| {},
        }
    }

    pub fn with_grid_offset(mut self, offset: GridDelta) -> Self {
        self.grid_offset = offset;
        self
    }
}

#[derive(Clone)]
pub struct TilemapHandles {
    pub image: Handle<Image>,
    pub layout: Handle<TextureAtlasLayout>,
}

impl TilemapHandles {
    pub fn sprite(&self, atlas_index: usize) -> Sprite {
        Sprite::from_atlas_image(
            self.image.clone(),
            TextureAtlas::from(self.layout.clone()).with_index(atlas_index),
        )
    }
}

/// Prepares tilemap handles by loading the image and creating the atlas layout.
/// 
/// # Arguments
/// * `asset_server` - Reference to the asset server for loading images
/// * `atlas_layouts` - Mutable reference to atlas layout assets for storing the layout
/// * `assets_directory` - Directory containing the tilemap assets
/// * `tilemap_file` - Filename of the tilemap image
pub fn prepare_tilemap_handles(
    asset_server: &AssetServer,
    atlas_layouts: &mut Assets<TextureAtlasLayout>,
    assets_directory: &str,
    tilemap_file: &str,
) -> TilemapHandles {
    let image = asset_server.load::<Image>(format!("{assets_directory}/{tilemap_file}"));
    
    let mut layout = TextureAtlasLayout::new_empty(TILEMAP.atlas_size());
    for index in 0..TILEMAP.sprites.len() {
        layout.add_texture(TILEMAP.sprite_rect(index));
    }
    let layout = atlas_layouts.add(layout);

    TilemapHandles { image, layout }
}

/// Converts asset definitions into renderable model assets.
pub fn load_assets(
    tilemap_handles: &TilemapHandles,
    assets_definitions: Vec<Vec<SpawnableAsset>>,
) -> ModelsAssets<Sprite> {
    let mut models_assets = ModelsAssets::<Sprite>::new();
    
    for (model_index, assets) in assets_definitions.into_iter().enumerate() {
        for asset_def in assets {
            let SpawnableAsset {
                sprite_name,
                grid_offset,
                offset,
                components_spawner,
            } = asset_def;

            let Some(atlas_index) = TILEMAP.sprite_index(sprite_name) else {
                panic!("Unknown atlas sprite '{}'", sprite_name);
            };

            models_assets.add(
                model_index,
                ModelAsset {
                    assets_bundle: tilemap_handles.sprite(atlas_index),
                    grid_offset,
                    world_offset: offset,
                    spawn_commands: components_spawner,
                },
            );
        }
    }
    
    models_assets
}
```

---

## Migration Checklist

- [ ] Update `prepare_tilemap_handles` to use `&AssetServer` instead of `&Res<AssetServer>`
- [ ] Update `prepare_tilemap_handles` to use `&mut Assets<TextureAtlasLayout>` instead of `&mut ResMut<...>`
- [ ] Verify calling code still works (it should, thanks to `Deref`)
- [ ] Update `create_character_atlas_layout` in `spawn.rs` with same pattern
- [ ] Search for other `&Res<` or `&ResMut<` in helper functions
- [ ] Add documentation explaining the parameter types
- [ ] Consider adding unit tests now that helpers are easier to test

---

## File Structure

No new files needed - this is a signature-level refactoring within existing files:

```
src/map/
â”œâ”€â”€ assets.rs      â†’ Updated function signatures
â””â”€â”€ ...

src/characters/
â”œâ”€â”€ spawn.rs       â†’ Updated create_character_atlas_layout
â””â”€â”€ ...
```

