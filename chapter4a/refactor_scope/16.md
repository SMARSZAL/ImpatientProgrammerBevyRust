# Refactoring Issue #16: `update_jump_state` Uses `for` Loop for Single Player

## The Problem

### Current Implementation

```rust
// src/characters/movement.rs
pub fn update_jump_state(
    mut query: Query<(
        &mut AnimationController,
        &mut AnimationState,
        &AnimationTimer,
        &Sprite,
        &CharacterEntry,
    ), With<Player>>,
) {
    for (mut animated, mut state, timer, sprite, config) in query.iter_mut() {
        if !state.is_jumping {
            continue;
        }
        
        let Some(atlas) = sprite.texture_atlas.as_ref() else {
            continue;
        };
        
        let Some(clip) = animated.get_clip(config) else {
            continue;
        };
        
        // Check if jump animation has completed
        if clip.is_complete(atlas.index, timer.just_finished()) {
            state.is_jumping = false;
            animated.current_animation = AnimationType::Walk;
        }
    }
}
```

### Contrast with `move_player` (Same File)

```rust
// src/characters/movement.rs
pub fn move_player(
    input: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(
        &mut Transform, 
        &mut AnimationController,
        &mut AnimationState,
        &CharacterEntry,
    ), With<Player>>,
) {
    let Ok((mut transform, mut animated, mut state, character)) = query.single_mut() else {
        return;  // Clear: expects exactly one player
    };
    
    // ... operates on THE player
}
```

### What's Wrong?

#### 1. **Inconsistent API Usage Within Same File**

Two functions in the same module, querying the same entity type (`With<Player>`), using different patterns:

| Function | Pattern | Implication |
|----------|---------|-------------|
| `move_player` | `query.single_mut()` | Expects exactly one player |
| `update_jump_state` | `query.iter_mut()` | Suggests multiple players possible |

This sends mixed signals to readers and maintainers.

#### 2. **Misleading Code Intent**

```rust
for (mut animated, mut state, ...) in query.iter_mut() {
```

A `for` loop implies:
- "There might be zero, one, or many entities"
- "We need to process each one"

But the game design is:
- There is exactly ONE player
- There will never be multiple players

The code doesn't match the design intent.

#### 3. **Silent Failure on Missing Player**

```rust
// With for loop: silently does nothing if no player
for (...) in query.iter_mut() {
    // Never executes if query is empty
}

// With single_mut: explicitly handles the case
let Ok((...)) = query.single_mut() else {
    warn!("update_jump_state: No player found!");
    return;
};
```

The `for` loop hides a potentially important bug (player not spawned yet, despawned accidentally, etc.).

#### 4. **Minor Performance Overhead**

While minimal, `iter_mut()` creates an iterator with bounds checking and iteration machinery. `single_mut()` is optimized for the single-entity case:

```rust
// iter_mut() internally:
// - Creates iterator struct
// - Checks if more items exist each iteration
// - Returns None when exhausted

// single_mut() internally:
// - Checks exactly one entity matches
// - Returns that entity directly
// - No iteration overhead
```

For a function called every frame, even minor optimizations matter.

#### 5. **Error Detection**

`single_mut()` returns `Err` if:
- Zero entities match (player not spawned)
- Multiple entities match (duplicate player bug)

Both are bugs worth catching! The `for` loop silently accepts either case.

---

## The Solution

### Direct Fix: Use `single_mut()`

```rust
pub fn update_jump_state(
    mut query: Query<(
        &mut AnimationController,
        &mut AnimationState,
        &AnimationTimer,
        &Sprite,
        &CharacterEntry,
    ), With<Player>>,
) {
    let Ok((mut animated, mut state, timer, sprite, config)) = query.single_mut() else {
        return;
    };
    
    if !state.is_jumping {
        return;
    }
    
    let Some(atlas) = sprite.texture_atlas.as_ref() else {
        return;
    };
    
    let Some(clip) = animated.get_clip(config) else {
        return;
    };
    
    if clip.is_complete(atlas.index, timer.just_finished()) {
        state.is_jumping = false;
        animated.current_animation = AnimationType::Walk;
    }
}
```

---

## Bevy Query Methods Comparison

### Overview

| Method | Returns | Use When | Panics? |
|--------|---------|----------|---------|
| `iter()` / `iter_mut()` | Iterator | Multiple entities expected | Never |
| `single()` / `single_mut()` | `Result<T, QuerySingleError>` | Exactly one entity expected | Never |
| `get_single()` / `get_single_mut()` | `Result<T, QuerySingleError>` | Same as above | Never |
| `single()` (unwrapped) | `T` | Exactly one, panic if not | Yes! |

### When to Use Each

```rust
// Multiple entities: enemies, bullets, particles
for (entity, health) in enemy_query.iter() {
    if health.current <= 0.0 {
        commands.entity(entity).despawn();
    }
}

// Exactly one entity, failure is recoverable: player, camera
let Ok((transform, player)) = player_query.single_mut() else {
    return; // Not spawned yet, or system ran at wrong time
};

// Exactly one entity, failure is a BUG: game state, settings
let config = config_query.single();  // Panic if missing - it's a bug!
```

---

## Expanded Solution: Consistent Player Query Pattern

Define a pattern and use it everywhere for player queries.

### Option A: Early Return Pattern (Current Project Style)

```rust
pub fn update_jump_state(mut query: Query<..., With<Player>>) {
    let Ok((...)) = query.single_mut() else { return };
    // ... logic
}

pub fn move_player(mut query: Query<..., With<Player>>) {
    let Ok((...)) = query.single_mut() else { return };
    // ... logic
}

pub fn handle_player_input(mut query: Query<..., With<Player>>) {
    let Ok((...)) = query.single_mut() else { return };
    // ... logic
}
```

**Pros:** Consistent, graceful handling during spawn/despawn frames
**Cons:** Silently ignores missing player

### Option B: With Warning on Missing Player

```rust
pub fn update_jump_state(mut query: Query<..., With<Player>>) {
    let Ok((...)) = query.single_mut() else {
        // Only warn if this is unexpected (after loading)
        #[cfg(debug_assertions)]
        warn_once!("update_jump_state: Player not found");
        return;
    };
    // ... logic
}
```

**Pros:** Helps catch bugs during development
**Cons:** Slightly more verbose

### Option C: Run Condition (Cleanest)

```rust
// conditions.rs
pub fn player_exists(query: Query<(), With<Player>>) -> bool {
    query.single().is_ok()
}

// Plugin registration
app.add_systems(Update, (
    move_player,
    update_jump_state,
    // ... other player systems
).run_if(player_exists));
```

Then systems can assume player exists:

```rust
pub fn update_jump_state(mut query: Query<..., With<Player>>) {
    // Guaranteed to exist by run_if
    let (mut animated, mut state, timer, sprite, config) = query.single_mut().unwrap();
    
    // ... logic without else/return
}
```

**Pros:** Cleaner system code, explicit precondition
**Cons:** Systems can't run during player spawn frame

---

## Complete Refactored Code

```rust
// src/characters/movement.rs

use bevy::prelude::*;
use crate::characters::animation::*;
use crate::characters::config::{CharacterEntry, AnimationType};

#[derive(Component)]
pub struct Player;

/// Read directional input and return a direction vector
fn read_movement_input(input: &ButtonInput<KeyCode>) -> Vec2 {
    const MOVEMENT_KEYS: [(KeyCode, Vec2); 4] = [
        (KeyCode::ArrowLeft, Vec2::NEG_X),
        (KeyCode::ArrowRight, Vec2::X),
        (KeyCode::ArrowUp, Vec2::Y),
        (KeyCode::ArrowDown, Vec2::NEG_Y),
    ];
    
    MOVEMENT_KEYS.iter()
        .filter(|(key, _)| input.pressed(*key))
        .map(|(_, dir)| *dir)
        .sum()
}

fn calculate_movement_speed(character: &CharacterEntry, is_running: bool) -> f32 {
    if is_running {
        character.base_move_speed * character.run_speed_multiplier
    } else {
        character.base_move_speed
    }
}

/// Handles player movement input and updates position/animation state.
pub fn move_player(
    input: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(
        &mut Transform, 
        &mut AnimationController,
        &mut AnimationState,
        &CharacterEntry,
    ), With<Player>>,
) {
    // ✓ Using single_mut() - consistent pattern
    let Ok((mut transform, mut animated, mut state, character)) = query.single_mut() else {
        return;
    };
    
    let direction = read_movement_input(&input);
    
    if input.just_pressed(KeyCode::Space) {
        state.is_jumping = true;
        animated.current_animation = AnimationType::Jump;
    }
    
    let is_running = input.pressed(KeyCode::ShiftLeft) || input.pressed(KeyCode::ShiftRight);
    
    if direction != Vec2::ZERO {
        let move_speed = calculate_movement_speed(character, is_running);
        let delta = direction.normalize() * move_speed * time.delta_secs();
        transform.translation += delta.extend(0.0);
        
        animated.facing = Facing::from_direction(direction);
        
        if !state.is_jumping {
            state.is_moving = true;
            animated.current_animation = if is_running {
                AnimationType::Run
            } else {
                AnimationType::Walk
            };
        }
    } else if !state.is_jumping {
        state.is_moving = false;
        animated.current_animation = AnimationType::Walk;
    }
}

/// Checks if the jump animation has completed and resets jump state.
pub fn update_jump_state(
    mut query: Query<(
        &mut AnimationController,
        &mut AnimationState,
        &AnimationTimer,
        &Sprite,
        &CharacterEntry,
    ), With<Player>>,
) {
    // ✓ NOW using single_mut() - matches move_player pattern
    let Ok((mut animated, mut state, timer, sprite, config)) = query.single_mut() else {
        return;
    };
    
    // Early return if not jumping (cleaner than nested if)
    if !state.is_jumping {
        return;
    }
    
    let Some(atlas) = sprite.texture_atlas.as_ref() else {
        return;
    };
    
    let Some(clip) = animated.get_clip(config) else {
        return;
    };
    
    // Check if jump animation has completed
    if clip.is_complete(atlas.index, timer.just_finished()) {
        state.is_jumping = false;
        animated.current_animation = AnimationType::Walk;
    }
}
```

---

## Design Principles Applied

### 1. **Principle of Least Astonishment (POLA)**

> Code should behave in a way that users (developers) expect.

Developers expect:
- Similar queries → similar access patterns
- Single entity → single-entity method
- Multiple entities → iteration

Using `iter_mut()` for a single-entity query is surprising.

### 2. **Consistency**

> Similar problems should have similar solutions.

Both `move_player` and `update_jump_state`:
- Query the player entity
- Expect exactly one result
- Should use the same access pattern

### 3. **Fail Fast**

> Detect errors as early as possible.

```rust
// iter_mut(): Silently handles 0 or N players
for x in query.iter_mut() { /* might never run */ }

// single_mut(): Explicitly fails if not exactly 1 player
let Ok(x) = query.single_mut() else {
    // Opportunity to log, assert, or handle error
    return;
};
```

### 4. **Explicit Over Implicit**

> Make intentions clear in code.

```rust
// Implicit: "maybe there are players, maybe not"
for player in query.iter_mut() { ... }

// Explicit: "there should be exactly one player"
let player = query.single_mut()?;
```

### 5. **Self-Documenting Code**

The method choice documents the data model:

```rust
// Documents: "This system operates on THE player (singular)"
query.single_mut()

// Documents: "This system operates on ALL enemies (plural)"
query.iter_mut()
```

### 6. **Defensive Programming**

`single_mut()` returns `Result`, forcing you to handle the error case:

```rust
let Ok(player) = query.single_mut() else {
    // You MUST write code here
    // This is where you decide: return, panic, log, etc.
    return;
};
```

The `for` loop doesn't force any handling.

---

## When `for` Loop IS Appropriate

Don't blindly convert all `for` loops to `single_mut()`. Use iteration when:

### 1. Multiple Entities Are Expected

```rust
// Enemies - there will be many
for (entity, mut health, position) in enemy_query.iter_mut() {
    if in_damage_zone(position) {
        health.current -= 10.0;
    }
}
```

### 2. Zero Entities Is Valid

```rust
// Projectiles - might be none currently
for (entity, mut projectile) in projectile_query.iter_mut() {
    projectile.lifetime -= time.delta_secs();
    if projectile.lifetime <= 0.0 {
        commands.entity(entity).despawn();
    }
}
```

### 3. Future Scalability Expected

```rust
// Local multiplayer - currently 1 player, but might support more
for (player_id, mut transform, input_map) in player_query.iter_mut() {
    // Handle each player's input
}
```

### 4. System Handles Optional Component

```rust
// Some entities have this optional component
for (entity, maybe_buff) in query.iter() {
    if let Some(buff) = maybe_buff {
        // Process buff
    }
}
```

---

## Query Method Decision Tree

```
Is this query for a single, specific entity?
│
├─ NO → Use iter() / iter_mut()
│       Examples: enemies, bullets, particles
│
└─ YES → Is the entity guaranteed to exist?
         │
         ├─ YES (system resource, always-present singleton)
         │       → Use single() / single_mut() with .unwrap()
         │       → Or .expect("GameConfig must exist")
         │
         └─ NO (player, camera, might not be spawned yet)
                 → Use single() / single_mut() with else { return }
                 → Or use run_if(entity_exists) condition
```

---

## Broader Codebase Search

Check for other inconsistencies in the project:

### Pattern to Search For

```bash
# Find for loops with With<Player>
grep -n "With<Player>" src/**/*.rs | grep -v single
```

### Other Singleton Entities to Check

| Entity | Current Pattern | Should Be |
|--------|-----------------|-----------|
| Player | Mixed | `single_mut()` |
| Camera | Check | `single_mut()` if unique |
| GameState | Check | `single()` if resource-like |

---

## Migration Checklist

- [ ] Change `update_jump_state` from `iter_mut()` to `single_mut()`
- [ ] Add early return with `let Ok(...) = query.single_mut() else { return }`
- [ ] Convert nested `continue` statements to `return` (since we're not in a loop anymore)
- [ ] Verify behavior is unchanged
- [ ] Search for other `iter_mut()` on `With<Player>` queries
- [ ] Consider adding `run_if(player_exists)` for player systems
- [ ] Document the project convention in a comment or README

---

## Before & After Comparison

### Before

```rust
pub fn update_jump_state(
    mut query: Query<(...), With<Player>>,
) {
    for (mut animated, mut state, timer, sprite, config) in query.iter_mut() {
        if !state.is_jumping {
            continue;  // Skip to next iteration (but there is no next!)
        }
        
        let Some(atlas) = sprite.texture_atlas.as_ref() else {
            continue;  // Skip to next iteration
        };
        
        let Some(clip) = animated.get_clip(config) else {
            continue;  // Skip to next iteration
        };
        
        if clip.is_complete(atlas.index, timer.just_finished()) {
            state.is_jumping = false;
            animated.current_animation = AnimationType::Walk;
        }
    }
}
```

### After

```rust
pub fn update_jump_state(
    mut query: Query<(...), With<Player>>,
) {
    let Ok((mut animated, mut state, timer, sprite, config)) = query.single_mut() else {
        return;  // Exit system - no player
    };
    
    if !state.is_jumping {
        return;  // Exit system - not jumping
    }
    
    let Some(atlas) = sprite.texture_atlas.as_ref() else {
        return;  // Exit system - no atlas
    };
    
    let Some(clip) = animated.get_clip(config) else {
        return;  // Exit system - no clip
    };
    
    if clip.is_complete(atlas.index, timer.just_finished()) {
        state.is_jumping = false;
        animated.current_animation = AnimationType::Walk;
    }
}
```

**Changes:**
- `for ... in query.iter_mut()` → `let Ok(...) = query.single_mut() else { return }`
- `continue` → `return` (we're not in a loop anymore)
- Same logic, clearer intent, consistent with `move_player`

