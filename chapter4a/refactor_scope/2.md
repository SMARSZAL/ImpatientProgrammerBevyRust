# Refactoring Issue #2: No Game State Management

## The Problem

### Current Implementation

```rust
// src/characters/mod.rs
impl Plugin for CharactersPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(RonAssetPlugin::<CharactersList>::new(&["characters.ron"]))
            .init_resource::<spawn::CurrentCharacterIndex>()
            .add_systems(Startup, spawn::spawn_player)
            .add_systems(Update, (
                spawn::initialize_player_character,  // Runs EVERY frame!
                spawn::switch_character,             // Runs EVERY frame!
                movement::move_player,               // Runs EVERY frame!
                movement::update_jump_state,         // Runs EVERY frame!
                animation::animate_characters,       // Runs EVERY frame!
                animation::update_animation_flags,   // Runs EVERY frame!
            ));
    }
}
```

### The Polling Pattern in `initialize_player_character`

```rust
// src/characters/spawn.rs
pub fn initialize_player_character(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    characters_lists: Res<Assets<CharactersList>>,
    character_index: Res<CurrentCharacterIndex>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut query: Query<Entity, (With<Player>, Without<AnimationController>)>,
) {
    // This runs EVERY FRAME, checking if asset is ready
    let Some(characters_list_res) = characters_list_res else {
        return;  // Asset handle not set yet - early return
    };
    
    for entity in query.iter_mut() {
        let Some(characters_list) = characters_lists.get(&characters_list_res.handle) else {
            continue;  // Asset not loaded yet - keep polling
        };
        
        // Finally do the actual work...
    }
}
```

### What's Wrong?

#### 1. **Wasteful Frame-by-Frame Polling**

Every single frame, `initialize_player_character`:
- Checks if the resource exists
- Checks if the asset is loaded
- Queries for uninitialized players

At 60 FPS, that's 60 unnecessary checks per second after initialization completes (for the rest of the game).

#### 2. **No Concept of Game Phases**

The game has implicit phases:
1. **Loading** - Assets being loaded, player not ready
2. **Playing** - Everything initialized, gameplay active
3. (Future) **Paused** - Game frozen, menu visible
4. (Future) **GameOver** - End state

But the code doesn't model these phases. Systems run unconditionally.

#### 3. **Scattered "Am I Ready?" Checks**

Multiple systems have their own readiness checks:

```rust
// spawn.rs
let Some(characters_list_res) = characters_list_res else { return; };

// spawn.rs (switch_character)
let Some(characters_list_res) = characters_list_res else { return; };
let Some(characters_list) = characters_lists.get(&...) else { return; };

// movement.rs
let Ok((...)) = query.single_mut() else { return; };
```

Each system independently decides if it can run. This is fragile and duplicative.

#### 4. **Race Conditions During Loading**

Without explicit states, systems might run in unexpected orders during the loading phase:
- `move_player` could query a player that's spawned but not initialized
- `animate_characters` could try to animate before atlas is set up
- Input could be processed before the game is ready

#### 5. **No Clean Extension Path**

Want to add a pause menu?
- Currently: Add `if paused { return; }` to every system
- With states: Add `.run_if(in_state(GameState::Playing))`

Want to add a loading screen?
- Currently: Complex conditionals everywhere
- With states: Systems for `Loading` state handle the screen

---

## Understanding Bevy's State System

### What Are States?

States are a way to conditionally run systems based on the current game phase:

```rust
#[derive(States, Default, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GameState {
    #[default]
    Loading,
    Playing,
    Paused,
    GameOver,
}
```

### State Lifecycle

```
┌─────────────────────────────────────────────────────────────────────┐
│                        STATE: Loading                                │
│                                                                      │
│  OnEnter(Loading)     →  Systems run ONCE when entering Loading     │
│  Update + run_if      →  Systems run each frame while in Loading    │
│  OnExit(Loading)      →  Systems run ONCE when leaving Loading      │
│                                                                      │
└─────────────────────────────────┬───────────────────────────────────┘
                                  │
                        next_state.set(Playing)
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        STATE: Playing                                │
│                                                                      │
│  OnEnter(Playing)     →  Systems run ONCE when entering Playing     │
│  Update + run_if      →  Systems run each frame while in Playing    │
│  OnExit(Playing)      →  Systems run ONCE when leaving Playing      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Key State Schedules

| Schedule | When It Runs | Use Case |
|----------|--------------|----------|
| `OnEnter(State)` | Once, when transitioning INTO this state | Setup, spawn entities |
| `Update` with `run_if(in_state(State))` | Every frame while in this state | Gameplay logic |
| `OnExit(State)` | Once, when transitioning OUT of this state | Cleanup, despawn |
| `OnTransition { from, to }` | During specific transition | Migration logic |

---

## The Solution

### Step 1: Define Game States

```rust
// src/state.rs (NEW FILE)
use bevy::prelude::*;

/// High-level game states controlling which systems run.
#[derive(States, Default, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GameState {
    /// Assets are being loaded, showing loading screen
    #[default]
    Loading,
    
    /// Main gameplay is active
    Playing,
    
    /// Game is paused, menu visible
    Paused,
}

/// Sub-states for more granular control (optional)
#[derive(SubStates, Default, Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[source(GameState = GameState::Playing)]
pub enum PlayingState {
    #[default]
    Exploring,
    InCombat,
    InDialog,
}
```

### Step 2: Create a State Plugin

```rust
// src/state.rs (continued)

pub struct GameStatePlugin;

impl Plugin for GameStatePlugin {
    fn build(&self, app: &mut App) {
        app
            // Initialize state
            .init_state::<GameState>()
            
            // Loading state systems
            .add_systems(Update, 
                check_assets_loaded.run_if(in_state(GameState::Loading))
            )
            
            // Transition handling
            .add_systems(OnEnter(GameState::Playing), on_enter_playing)
            .add_systems(OnExit(GameState::Playing), on_exit_playing)
            
            // Pause handling
            .add_systems(Update, 
                toggle_pause.run_if(in_state(GameState::Playing).or(in_state(GameState::Paused)))
            );
    }
}

/// Check if all required assets are loaded, then transition to Playing
fn check_assets_loaded(
    asset_server: Res<AssetServer>,
    characters_list_res: Option<Res<CharactersListResource>>,
    characters_lists: Res<Assets<CharactersList>>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    // Check if character list is loaded
    let Some(list_res) = characters_list_res else {
        return; // Handle not set yet
    };
    
    let Some(_) = characters_lists.get(&list_res.handle) else {
        return; // Asset not loaded yet
    };
    
    // All assets loaded! Transition to Playing
    info!("All assets loaded, starting game!");
    next_state.set(GameState::Playing);
}

fn on_enter_playing() {
    info!("Entered Playing state");
}

fn on_exit_playing() {
    info!("Exited Playing state");
}

fn toggle_pause(
    input: Res<ButtonInput<KeyCode>>,
    current_state: Res<State<GameState>>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    if input.just_pressed(KeyCode::Escape) {
        match current_state.get() {
            GameState::Playing => next_state.set(GameState::Paused),
            GameState::Paused => next_state.set(GameState::Playing),
            _ => {}
        }
    }
}
```

### Step 3: Refactor Characters Plugin

```rust
// src/characters/mod.rs
use bevy::prelude::*;
use bevy_common_assets::ron::RonAssetPlugin;
use crate::state::GameState;

pub struct CharactersPlugin;

impl Plugin for CharactersPlugin {
    fn build(&self, app: &mut App) {
        app
            // Asset loading (runs always, Bevy handles this)
            .add_plugins(RonAssetPlugin::<CharactersList>::new(&["characters.ron"]))
            .init_resource::<spawn::CurrentCharacterIndex>()
            
            // Startup systems (run once at app start)
            .add_systems(Startup, spawn::spawn_player)
            
            // One-time initialization when entering Playing state
            .add_systems(OnEnter(GameState::Playing), 
                spawn::initialize_player_character
            )
            
            // Gameplay systems - only run during Playing state
            .add_systems(Update, (
                spawn::switch_character,
                movement::move_player,
                movement::update_jump_state,
                animation::animate_characters,
                animation::update_animation_flags,
            ).run_if(in_state(GameState::Playing)));
    }
}
```

### Step 4: Simplify `initialize_player_character`

Now that it only runs in `OnEnter(Playing)`, we know assets are loaded!

```rust
// src/characters/spawn.rs

/// Initialize the player character with loaded assets.
/// Only called when entering Playing state - assets guaranteed to be loaded.
pub fn initialize_player_character(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
    characters_lists: Res<Assets<CharactersList>>,
    character_index: Res<CurrentCharacterIndex>,
    characters_list_res: Res<CharactersListResource>,  // No longer Option!
    query: Query<Entity, (With<Player>, Without<AnimationController>)>,
) {
    // Assets are guaranteed loaded - we're in Playing state
    let characters_list = characters_lists.get(&characters_list_res.handle)
        .expect("CharactersList must be loaded when entering Playing state");
    
    for entity in query.iter() {
        if character_index.index >= characters_list.characters.len() {
            error!("Character index {} out of bounds", character_index.index);
            continue;
        }
        
        let character_entry = &characters_list.characters[character_index.index];
        
        let texture = asset_server.load(&character_entry.texture_path);
        let layout = create_character_atlas_layout(&mut atlas_layouts, character_entry);
        
        let sprite = Sprite::from_atlas_image(
            texture,
            TextureAtlas { layout, index: 0 },
        );
        
        commands.entity(entity).insert((
            AnimationController::default(),
            AnimationState::default(),
            AnimationTimer(Timer::from_seconds(DEFAULT_ANIMATION_FRAME_TIME, TimerMode::Repeating)),
            character_entry.clone(),
            sprite,
        ));
        
        info!("Initialized player with character: {}", character_entry.name);
    }
}
```

### Step 5: Update Main

```rust
// src/main.rs
mod state;
mod map;
mod characters;

use bevy::prelude::*;
use crate::state::GameStatePlugin;

fn main() {
    let map_size = map::generate::map_pixel_dimensions();

    App::new()
        .insert_resource(ClearColor(Color::WHITE))
        .add_plugins(DefaultPlugins
            .set(AssetPlugin {
                file_path: "src/assets".into(),
                ..default()
            })
            .set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: (map_size.x as u32, map_size.y as u32).into(),
                    resizable: false,
                    ..default()
                }),
                ..default()
            })
            .set(ImagePlugin::default_nearest())
        )
        .add_plugins(ProcGenSimplePlugin::<Cartesian3D, Sprite>::default())
        .add_plugins(GameStatePlugin)  // NEW: State management
        .add_plugins(characters::CharactersPlugin)
        .add_systems(Startup, (setup_camera, map::generate::setup_generator))
        .run();
}
```

---

## Adding a Loading Screen

With states, adding a loading screen is trivial:

```rust
// src/loading.rs
use bevy::prelude::*;
use crate::state::GameState;

pub struct LoadingPlugin;

impl Plugin for LoadingPlugin {
    fn build(&self, app: &mut App) {
        app
            .add_systems(OnEnter(GameState::Loading), spawn_loading_screen)
            .add_systems(Update, animate_loading.run_if(in_state(GameState::Loading)))
            .add_systems(OnExit(GameState::Loading), despawn_loading_screen);
    }
}

#[derive(Component)]
struct LoadingScreen;

fn spawn_loading_screen(mut commands: Commands) {
    commands.spawn((
        LoadingScreen,
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.1, 0.1, 0.15)),
    )).with_children(|parent| {
        parent.spawn((
            Text::new("Loading..."),
            TextFont {
                font_size: 48.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
}

fn animate_loading(
    time: Res<Time>,
    mut query: Query<&mut Text, With<LoadingScreen>>,
) {
    // Animate dots: "Loading." -> "Loading.." -> "Loading..."
    for mut text in query.iter_mut() {
        let dots = ((time.elapsed_secs() * 2.0) as usize % 4);
        text.0 = format!("Loading{}", ".".repeat(dots));
    }
}

fn despawn_loading_screen(
    mut commands: Commands,
    query: Query<Entity, With<LoadingScreen>>,
) {
    for entity in query.iter() {
        commands.entity(entity).despawn_recursive();
    }
}
```

---

## Adding Pause Functionality

```rust
// src/pause.rs
use bevy::prelude::*;
use crate::state::GameState;

pub struct PausePlugin;

impl Plugin for PausePlugin {
    fn build(&self, app: &mut App) {
        app
            .add_systems(OnEnter(GameState::Paused), spawn_pause_menu)
            .add_systems(OnExit(GameState::Paused), despawn_pause_menu);
    }
}

#[derive(Component)]
struct PauseMenu;

fn spawn_pause_menu(mut commands: Commands) {
    commands.spawn((
        PauseMenu,
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.7)),
    )).with_children(|parent| {
        parent.spawn((
            Text::new("PAUSED\n\nPress ESC to resume"),
            TextFont {
                font_size: 36.0,
                ..default()
            },
            TextColor(Color::WHITE),
            TextLayout::new_with_justify(JustifyText::Center),
        ));
    });
}

fn despawn_pause_menu(
    mut commands: Commands,
    query: Query<Entity, With<PauseMenu>>,
) {
    for entity in query.iter() {
        commands.entity(entity).despawn_recursive();
    }
}
```

---

## State-Based System Organization

### Visual Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                     GameState::Loading                               │
├─────────────────────────────────────────────────────────────────────┤
│ OnEnter:  spawn_loading_screen                                      │
│ Update:   check_assets_loaded, animate_loading                      │
│ OnExit:   despawn_loading_screen                                    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                    Assets loaded → next_state.set(Playing)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     GameState::Playing                               │
├─────────────────────────────────────────────────────────────────────┤
│ OnEnter:  initialize_player_character, on_enter_playing             │
│ Update:   move_player, switch_character, animate_characters,        │
│           update_jump_state, update_animation_flags                 │
│ OnExit:   on_exit_playing                                           │
└─────────────────────────────────────────────────────────────────────┘
                              │
                    ESC pressed → next_state.set(Paused)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     GameState::Paused                                │
├─────────────────────────────────────────────────────────────────────┤
│ OnEnter:  spawn_pause_menu                                          │
│ Update:   toggle_pause (to resume)                                  │
│ OnExit:   despawn_pause_menu                                        │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Design Principles Applied

### 1. **State Pattern (GoF)**

> Allow an object to alter its behavior when its internal state changes.

The game's behavior changes completely based on `GameState`:
- Loading: Show loading screen, check assets
- Playing: Run gameplay systems
- Paused: Freeze gameplay, show menu

### 2. **Separation of Concerns**

Each state has its own concerns:

| State | Concern |
|-------|---------|
| Loading | Asset management, progress display |
| Playing | Gameplay logic, player interaction |
| Paused | Menu UI, resume/quit options |

Systems for one state don't need to know about other states.

### 3. **Single Responsibility Principle**

Systems no longer check "am I allowed to run?" - that's the state system's job:

```rust
// Before: System checks its own readiness
pub fn move_player(...) {
    let Some(x) = maybe_resource else { return; };  // Readiness check
    // ... actual logic
}

// After: State system handles readiness
pub fn move_player(...) {
    // Just the actual logic - we know we're in Playing state
}
```

### 4. **Inversion of Control**

The state system controls when systems run, not the systems themselves:

```rust
// Before: System decides to run
pub fn initialize_player(...) {
    if !ready { return; }  // System decides
    // ...
}

// After: Framework decides based on state
.add_systems(OnEnter(GameState::Playing), initialize_player)
// Framework ensures this runs exactly once at the right time
```

### 5. **Fail Fast**

With explicit states, invalid operations fail immediately:

```rust
// If move_player runs during Loading, the state system misconfigured
// This is an obvious bug, not a silent skip
```

### 6. **Open/Closed Principle**

Adding new states doesn't modify existing systems:

```rust
// Add GameOver state without changing Playing systems
.add_systems(OnEnter(GameState::GameOver), show_game_over_screen)
.add_systems(Update, handle_restart.run_if(in_state(GameState::GameOver)))
```

### 7. **Explicit State Machines**

The game flow is documented in code:

```rust
pub enum GameState {
    Loading,  // Start here
    Playing,  // Main game
    Paused,   // From Playing, can return
    GameOver, // End state
}
```

This is self-documenting architecture.

### 8. **Event-Driven Architecture**

State transitions are like events:
- `OnEnter` = "state entered" event
- `OnExit` = "state exited" event

Systems react to state changes, not poll for them.

---

## Performance Comparison

### Before: Polling Every Frame

```
Frame 1:   check_ready() → not ready → return
Frame 2:   check_ready() → not ready → return
Frame 3:   check_ready() → not ready → return
...
Frame 60:  check_ready() → not ready → return
Frame 61:  check_ready() → READY! → initialize
Frame 62:  check_ready() → already done → return (but still checking!)
Frame 63:  check_ready() → already done → return
...forever
```

**Cost:** Query + checks every frame for the entire game session.

### After: State-Based

```
Loading state:
  Frame 1:   check_assets() → not loaded
  Frame 2:   check_assets() → not loaded
  ...
  Frame 61:  check_assets() → loaded! → transition to Playing

Playing state:
  OnEnter:   initialize_player() → runs ONCE
  Frame 62:  move_player() → no readiness check needed
  Frame 63:  move_player() → no readiness check needed
  ...forever (clean gameplay code)
```

**Cost:** Check only during Loading. Initialize once. No polling during gameplay.

---

## Advanced: Asset Loading with Bevy's AssetServer

For robust asset loading, use Bevy's `LoadState`:

```rust
fn check_assets_loaded(
    asset_server: Res<AssetServer>,
    characters_list_res: Option<Res<CharactersListResource>>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let Some(list_res) = characters_list_res else { return };
    
    // Use Bevy's built-in load state checking
    match asset_server.get_load_state(&list_res.handle) {
        Some(LoadState::Loaded) => {
            info!("All assets loaded!");
            next_state.set(GameState::Playing);
        }
        Some(LoadState::Failed(error)) => {
            error!("Asset loading failed: {:?}", error);
            // Could transition to an Error state
        }
        _ => {
            // Still loading...
        }
    }
}
```

Or use `LoadingStateHandler` for multiple assets:

```rust
use bevy::asset::LoadedFolder;

#[derive(Resource)]
struct GameAssets {
    characters: Handle<CharactersList>,
    tilemap: Handle<Image>,
    // ... other assets
}

fn check_all_assets_loaded(
    asset_server: Res<AssetServer>,
    game_assets: Res<GameAssets>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let all_loaded = [
        asset_server.is_loaded_with_dependencies(&game_assets.characters),
        asset_server.is_loaded_with_dependencies(&game_assets.tilemap),
    ].iter().all(|&loaded| loaded);
    
    if all_loaded {
        next_state.set(GameState::Playing);
    }
}
```

---

## Migration Checklist

- [ ] Create `src/state.rs` with `GameState` enum
- [ ] Create `GameStatePlugin` with state initialization
- [ ] Implement `check_assets_loaded` system for Loading state
- [ ] Move `initialize_player_character` to `OnEnter(GameState::Playing)`
- [ ] Add `.run_if(in_state(GameState::Playing))` to gameplay systems
- [ ] Remove redundant `Option<Res<...>>` parameters from systems
- [ ] Remove readiness checks from systems (they're guaranteed by state)
- [ ] (Optional) Add Loading screen with `LoadingPlugin`
- [ ] (Optional) Add Pause functionality with `PausePlugin`
- [ ] Update `main.rs` to add `GameStatePlugin`
- [ ] Test state transitions work correctly

---

## File Structure After Refactoring

```
src/
├── main.rs
├── state.rs           → NEW: GameState, GameStatePlugin
├── loading.rs         → NEW (optional): Loading screen
├── pause.rs           → NEW (optional): Pause menu
├── characters/
│   ├── mod.rs         → Updated with state-gated systems
│   ├── spawn.rs       → Simplified, no polling
│   └── ...
└── map/
    └── ...
```

